import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/quilljs/node_modules/lodash/dist/lodash.js
var require_lodash = __commonJS({
  "node_modules/quilljs/node_modules/lodash/dist/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var arrayPool = [], objectPool = [];
      var idCounter = 0;
      var keyPrefix = +/* @__PURE__ */ new Date() + "";
      var largeArraySize = 75;
      var maxPoolSize = 40;
      var whitespace = (
        // whitespace
        " 	\v\f \uFEFF\n\r\u2028\u2029 ᠎             　"
      );
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reFuncName = /^\s*function[ \n\r\t]+\w/;
      var reInterpolate = /<%=([\s\S]+?)%>/g;
      var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
      var reNoMatch = /($^)/;
      var reThis = /\bthis\b/;
      var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
      var contextProps = [
        "Array",
        "Boolean",
        "Date",
        "Function",
        "Math",
        "Number",
        "Object",
        "RegExp",
        "String",
        "_",
        "attachEvent",
        "clearTimeout",
        "isFinite",
        "isNaN",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = 0;
      var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
      var cloneableClasses = {};
      cloneableClasses[funcClass] = false;
      cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
      var debounceOptions = {
        "leading": false,
        "maxWait": 0,
        "trailing": false
      };
      var descriptor = {
        "configurable": false,
        "enumerable": false,
        "value": null,
        "writable": false
      };
      var objectTypes = {
        "boolean": false,
        "function": true,
        "object": true,
        "number": false,
        "string": false,
        "undefined": false
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var root = objectTypes[typeof window] && window || this;
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var freeGlobal = objectTypes[typeof global] && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
      }
      function baseIndexOf(array, value, fromIndex) {
        var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function cacheIndexOf(cache, value) {
        var type = typeof value;
        cache = cache.cache;
        if (type == "boolean" || value == null) {
          return cache[value] ? 0 : -1;
        }
        if (type != "number" && type != "string") {
          type = "object";
        }
        var key = type == "number" ? value : keyPrefix + value;
        cache = (cache = cache[type]) && cache[key];
        return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
      }
      function cachePush(value) {
        var cache = this.cache, type = typeof value;
        if (type == "boolean" || value == null) {
          cache[value] = true;
        } else {
          if (type != "number" && type != "string") {
            type = "object";
          }
          var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
          if (type == "object") {
            (typeCache[key] || (typeCache[key] = [])).push(value);
          } else {
            typeCache[key] = true;
          }
        }
      }
      function charAtCallback(value) {
        return value.charCodeAt(0);
      }
      function compareAscending(a, b) {
        var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
        while (++index < length) {
          var value = ac[index], other = bc[index];
          if (value !== other) {
            if (value > other || typeof value == "undefined") {
              return 1;
            }
            if (value < other || typeof other == "undefined") {
              return -1;
            }
          }
        }
        return a.index - b.index;
      }
      function createCache(array) {
        var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
        if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
          return false;
        }
        var cache = getObject();
        cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
        var result = getObject();
        result.array = array;
        result.cache = cache;
        result.push = cachePush;
        while (++index < length) {
          result.push(array[index]);
        }
        return result;
      }
      function escapeStringChar(match) {
        return "\\" + stringEscapes[match];
      }
      function getArray() {
        return arrayPool.pop() || [];
      }
      function getObject() {
        return objectPool.pop() || {
          "array": null,
          "cache": null,
          "criteria": null,
          "false": false,
          "index": 0,
          "null": false,
          "number": null,
          "object": null,
          "push": null,
          "string": null,
          "true": false,
          "undefined": false,
          "value": null
        };
      }
      function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
          arrayPool.push(array);
        }
      }
      function releaseObject(object) {
        var cache = object.cache;
        if (cache) {
          releaseObject(cache);
        }
        object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
        if (objectPool.length < maxPoolSize) {
          objectPool.push(object);
        }
      }
      function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == "undefined") {
          end = array ? array.length : 0;
        }
        var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
        while (++index < length) {
          result[index] = array[start + index];
        }
        return result;
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array2 = context.Array, Boolean = context.Boolean, Date2 = context.Date, Function = context.Function, Math2 = context.Math, Number = context.Number, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError = context.TypeError;
        var arrayRef = [];
        var objectProto = Object2.prototype;
        var oldDash = context._;
        var toString = objectProto.toString;
        var reNative = RegExp2(
          "^" + String2(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$"
        );
        var ceil = Math2.ceil, clearTimeout2 = context.clearTimeout, floor = Math2.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object2.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout2 = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
        var defineProperty = function() {
          try {
            var o = {}, func = isNative(func = Object2.defineProperty) && func, result2 = func(o, o, o) && func;
          } catch (e) {
          }
          return result2;
        }();
        var nativeCreate = isNative(nativeCreate = Object2.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array2.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object2.keys) && nativeKeys, nativeMax = Math2.max, nativeMin = Math2.min, nativeParseInt = context.parseInt, nativeRandom = Math2.random;
        var ctorByClass = {};
        ctorByClass[arrayClass] = Array2;
        ctorByClass[boolClass] = Boolean;
        ctorByClass[dateClass] = Date2;
        ctorByClass[funcClass] = Function;
        ctorByClass[objectClass] = Object2;
        ctorByClass[numberClass] = Number;
        ctorByClass[regexpClass] = RegExp2;
        ctorByClass[stringClass] = String2;
        function lodash(value) {
          return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
        }
        function lodashWrapper(value, chainAll) {
          this.__chain__ = !!chainAll;
          this.__wrapped__ = value;
        }
        lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
        support.funcNames = typeof Function.name == "string";
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          "escape": /<%-([\s\S]+?)%>/g,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          "evaluate": /<%([\s\S]+?)%>/g,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type string
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type Object
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type Function
             */
            "_": lodash
          }
        };
        function baseBind(bindData) {
          var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
          function bound() {
            if (partialArgs) {
              var args = slice(partialArgs);
              push.apply(args, arguments);
            }
            if (this instanceof bound) {
              var thisBinding = baseCreate(func.prototype), result2 = func.apply(thisBinding, args || arguments);
              return isObject(result2) ? result2 : thisBinding;
            }
            return func.apply(thisArg, args || arguments);
          }
          setBindData(bound, bindData);
          return bound;
        }
        function baseClone(value, isDeep, callback, stackA, stackB) {
          if (callback) {
            var result2 = callback(value);
            if (typeof result2 != "undefined") {
              return result2;
            }
          }
          var isObj = isObject(value);
          if (isObj) {
            var className = toString.call(value);
            if (!cloneableClasses[className]) {
              return value;
            }
            var ctor = ctorByClass[className];
            switch (className) {
              case boolClass:
              case dateClass:
                return new ctor(+value);
              case numberClass:
              case stringClass:
                return new ctor(value);
              case regexpClass:
                result2 = ctor(value.source, reFlags.exec(value));
                result2.lastIndex = value.lastIndex;
                return result2;
            }
          } else {
            return value;
          }
          var isArr = isArray(value);
          if (isDeep) {
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
            var length = stackA.length;
            while (length--) {
              if (stackA[length] == value) {
                return stackB[length];
              }
            }
            result2 = isArr ? ctor(value.length) : {};
          } else {
            result2 = isArr ? slice(value) : assign({}, value);
          }
          if (isArr) {
            if (hasOwnProperty.call(value, "index")) {
              result2.index = value.index;
            }
            if (hasOwnProperty.call(value, "input")) {
              result2.input = value.input;
            }
          }
          if (!isDeep) {
            return result2;
          }
          stackA.push(value);
          stackB.push(result2);
          (isArr ? forEach : forOwn)(value, function(objValue, key) {
            result2[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
          });
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return result2;
        }
        function baseCreate(prototype, properties) {
          return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        if (!nativeCreate) {
          baseCreate = /* @__PURE__ */ function() {
            function Object3() {
            }
            return function(prototype) {
              if (isObject(prototype)) {
                Object3.prototype = prototype;
                var result2 = new Object3();
                Object3.prototype = null;
              }
              return result2 || context.Object();
            };
          }();
        }
        function baseCreateCallback(func, thisArg, argCount) {
          if (typeof func != "function") {
            return identity;
          }
          if (typeof thisArg == "undefined" || !("prototype" in func)) {
            return func;
          }
          var bindData = func.__bindData__;
          if (typeof bindData == "undefined") {
            if (support.funcNames) {
              bindData = !func.name;
            }
            bindData = bindData || !support.funcDecomp;
            if (!bindData) {
              var source = fnToString.call(func);
              if (!support.funcNames) {
                bindData = !reFuncName.test(source);
              }
              if (!bindData) {
                bindData = reThis.test(source);
                setBindData(func, bindData);
              }
            }
          }
          if (bindData === false || bindData !== true && bindData[1] & 1) {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 2:
              return function(a, b) {
                return func.call(thisArg, a, b);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
          }
          return bind(func, thisArg);
        }
        function baseCreateWrapper(bindData) {
          var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
          var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
          function bound() {
            var thisBinding = isBind ? thisArg : this;
            if (partialArgs) {
              var args = slice(partialArgs);
              push.apply(args, arguments);
            }
            if (partialRightArgs || isCurry) {
              args || (args = slice(arguments));
              if (partialRightArgs) {
                push.apply(args, partialRightArgs);
              }
              if (isCurry && args.length < arity) {
                bitmask |= 16 & ~32;
                return baseCreateWrapper([func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity]);
              }
            }
            args || (args = arguments);
            if (isBindKey) {
              func = thisBinding[key];
            }
            if (this instanceof bound) {
              thisBinding = baseCreate(func.prototype);
              var result2 = func.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            }
            return func.apply(thisBinding, args);
          }
          setBindData(bound, bindData);
          return bound;
        }
        function baseDifference(array, values2) {
          var index = -1, indexOf2 = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf2 === baseIndexOf, result2 = [];
          if (isLarge) {
            var cache = createCache(values2);
            if (cache) {
              indexOf2 = cacheIndexOf;
              values2 = cache;
            } else {
              isLarge = false;
            }
          }
          while (++index < length) {
            var value = array[index];
            if (indexOf2(values2, value) < 0) {
              result2.push(value);
            }
          }
          if (isLarge) {
            releaseObject(values2);
          }
          return result2;
        }
        function baseFlatten(array, isShallow, isStrict, fromIndex) {
          var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
              if (!isShallow) {
                value = baseFlatten(value, isShallow, isStrict);
              }
              var valIndex = -1, valLength = value.length, resIndex = result2.length;
              result2.length += valLength;
              while (++valIndex < valLength) {
                result2[resIndex++] = value[valIndex];
              }
            } else if (!isStrict) {
              result2.push(value);
            }
          }
          return result2;
        }
        function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
          if (callback) {
            var result2 = callback(a, b);
            if (typeof result2 != "undefined") {
              return !!result2;
            }
          }
          if (a === b) {
            return a !== 0 || 1 / a == 1 / b;
          }
          var type = typeof a, otherType = typeof b;
          if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
            return false;
          }
          if (a == null || b == null) {
            return a === b;
          }
          var className = toString.call(a), otherClass = toString.call(b);
          if (className == argsClass) {
            className = objectClass;
          }
          if (otherClass == argsClass) {
            otherClass = objectClass;
          }
          if (className != otherClass) {
            return false;
          }
          switch (className) {
            case boolClass:
            case dateClass:
              return +a == +b;
            case numberClass:
              return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
            case regexpClass:
            case stringClass:
              return a == String2(b);
          }
          var isArr = className == arrayClass;
          if (!isArr) {
            var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
            if (aWrapped || bWrapped) {
              return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
            }
            if (className != objectClass) {
              return false;
            }
            var ctorA = a.constructor, ctorB = b.constructor;
            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
              return false;
            }
          }
          var initedStack = !stackA;
          stackA || (stackA = getArray());
          stackB || (stackB = getArray());
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == a) {
              return stackB[length] == b;
            }
          }
          var size2 = 0;
          result2 = true;
          stackA.push(a);
          stackB.push(b);
          if (isArr) {
            length = a.length;
            size2 = b.length;
            result2 = size2 == length;
            if (result2 || isWhere) {
              while (size2--) {
                var index = length, value = b[size2];
                if (isWhere) {
                  while (index--) {
                    if (result2 = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                      break;
                    }
                  }
                } else if (!(result2 = baseIsEqual(a[size2], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            }
          } else {
            forIn(b, function(value2, key, b2) {
              if (hasOwnProperty.call(b2, key)) {
                size2++;
                return result2 = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value2, callback, isWhere, stackA, stackB);
              }
            });
            if (result2 && !isWhere) {
              forIn(a, function(value2, key, a2) {
                if (hasOwnProperty.call(a2, key)) {
                  return result2 = --size2 > -1;
                }
              });
            }
          }
          stackA.pop();
          stackB.pop();
          if (initedStack) {
            releaseArray(stackA);
            releaseArray(stackB);
          }
          return result2;
        }
        function baseMerge(object, source, callback, stackA, stackB) {
          (isArray(source) ? forEach : forOwn)(source, function(source2, key) {
            var found, isArr, result2 = source2, value = object[key];
            if (source2 && ((isArr = isArray(source2)) || isPlainObject(source2))) {
              var stackLength = stackA.length;
              while (stackLength--) {
                if (found = stackA[stackLength] == source2) {
                  value = stackB[stackLength];
                  break;
                }
              }
              if (!found) {
                var isShallow;
                if (callback) {
                  result2 = callback(value, source2);
                  if (isShallow = typeof result2 != "undefined") {
                    value = result2;
                  }
                }
                if (!isShallow) {
                  value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                }
                stackA.push(source2);
                stackB.push(value);
                if (!isShallow) {
                  baseMerge(value, source2, callback, stackA, stackB);
                }
              }
            } else {
              if (callback) {
                result2 = callback(value, source2);
                if (typeof result2 == "undefined") {
                  result2 = source2;
                }
              }
              if (typeof result2 != "undefined") {
                value = result2;
              }
            }
            object[key] = value;
          });
        }
        function baseRandom(min2, max2) {
          return min2 + floor(nativeRandom() * (max2 - min2 + 1));
        }
        function baseUniq(array, isSorted, callback) {
          var index = -1, indexOf2 = getIndexOf(), length = array ? array.length : 0, result2 = [];
          var isLarge = !isSorted && length >= largeArraySize && indexOf2 === baseIndexOf, seen = callback || isLarge ? getArray() : result2;
          if (isLarge) {
            var cache = createCache(seen);
            indexOf2 = cacheIndexOf;
            seen = cache;
          }
          while (++index < length) {
            var value = array[index], computed = callback ? callback(value, index, array) : value;
            if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf2(seen, computed) < 0) {
              if (callback || isLarge) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
          if (isLarge) {
            releaseArray(seen.array);
            releaseObject(seen);
          } else if (callback) {
            releaseArray(seen);
          }
          return result2;
        }
        function createAggregator(setter) {
          return function(collection, callback, thisArg) {
            var result2 = {};
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == "number") {
              while (++index < length) {
                var value = collection[index];
                setter(result2, value, callback(value, index, collection), collection);
              }
            } else {
              forOwn(collection, function(value2, key, collection2) {
                setter(result2, value2, callback(value2, key, collection2), collection2);
              });
            }
            return result2;
          };
        }
        function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
          var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
          if (!isBindKey && !isFunction(func)) {
            throw new TypeError();
          }
          if (isPartial && !partialArgs.length) {
            bitmask &= ~16;
            isPartial = partialArgs = false;
          }
          if (isPartialRight && !partialRightArgs.length) {
            bitmask &= ~32;
            isPartialRight = partialRightArgs = false;
          }
          var bindData = func && func.__bindData__;
          if (bindData && bindData !== true) {
            bindData = slice(bindData);
            if (bindData[2]) {
              bindData[2] = slice(bindData[2]);
            }
            if (bindData[3]) {
              bindData[3] = slice(bindData[3]);
            }
            if (isBind && !(bindData[1] & 1)) {
              bindData[4] = thisArg;
            }
            if (!isBind && bindData[1] & 1) {
              bitmask |= 8;
            }
            if (isCurry && !(bindData[1] & 4)) {
              bindData[5] = arity;
            }
            if (isPartial) {
              push.apply(bindData[2] || (bindData[2] = []), partialArgs);
            }
            if (isPartialRight) {
              unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
            }
            bindData[1] |= bitmask;
            return createWrapper.apply(null, bindData);
          }
          var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
          return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
        }
        function escapeHtmlChar(match) {
          return htmlEscapes[match];
        }
        function getIndexOf() {
          var result2 = (result2 = lodash.indexOf) === indexOf ? baseIndexOf : result2;
          return result2;
        }
        function isNative(value) {
          return typeof value == "function" && reNative.test(value);
        }
        var setBindData = !defineProperty ? noop : function(func, value) {
          descriptor.value = value;
          defineProperty(func, "__bindData__", descriptor);
          descriptor.value = null;
        };
        function shimIsPlainObject(value) {
          var ctor, result2;
          if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
            return false;
          }
          forIn(value, function(value2, key) {
            result2 = key;
          });
          return typeof result2 == "undefined" || hasOwnProperty.call(value, result2);
        }
        function unescapeHtmlChar(match) {
          return htmlUnescapes[match];
        }
        function isArguments(value) {
          return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
        }
        var isArray = nativeIsArray || function(value) {
          return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
        };
        var shimKeys = function(object) {
          var index, iterable = object, result2 = [];
          if (!iterable) return result2;
          if (!objectTypes[typeof object]) return result2;
          for (index in iterable) {
            if (hasOwnProperty.call(iterable, index)) {
              result2.push(index);
            }
          }
          return result2;
        };
        var keys = !nativeKeys ? shimKeys : function(object) {
          if (!isObject(object)) {
            return [];
          }
          return nativeKeys(object);
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = invert(htmlEscapes);
        var reEscapedHtml = RegExp2("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp2("[" + keys(htmlEscapes).join("") + "]", "g");
        var assign = function(object, source, guard) {
          var index, iterable = object, result2 = iterable;
          if (!iterable) return result2;
          var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
          if (argsLength > 3 && typeof args[argsLength - 2] == "function") {
            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
          } else if (argsLength > 2 && typeof args[argsLength - 1] == "function") {
            callback = args[--argsLength];
          }
          while (++argsIndex < argsLength) {
            iterable = args[argsIndex];
            if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                result2[index] = callback ? callback(result2[index], iterable[index]) : iterable[index];
              }
            }
          }
          return result2;
        };
        function clone(value, isDeep, callback, thisArg) {
          if (typeof isDeep != "boolean" && isDeep != null) {
            thisArg = callback;
            callback = isDeep;
            isDeep = false;
          }
          return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
        }
        function cloneDeep(value, callback, thisArg) {
          return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
        }
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties ? assign(result2, properties) : result2;
        }
        var defaults = function(object, source, guard) {
          var index, iterable = object, result2 = iterable;
          if (!iterable) return result2;
          var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
          while (++argsIndex < argsLength) {
            iterable = args[argsIndex];
            if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                if (typeof result2[index] == "undefined") result2[index] = iterable[index];
              }
            }
          }
          return result2;
        };
        function findKey(object, callback, thisArg) {
          var result2;
          callback = lodash.createCallback(callback, thisArg, 3);
          forOwn(object, function(value, key, object2) {
            if (callback(value, key, object2)) {
              result2 = key;
              return false;
            }
          });
          return result2;
        }
        function findLastKey(object, callback, thisArg) {
          var result2;
          callback = lodash.createCallback(callback, thisArg, 3);
          forOwnRight(object, function(value, key, object2) {
            if (callback(value, key, object2)) {
              result2 = key;
              return false;
            }
          });
          return result2;
        }
        var forIn = function(collection, callback, thisArg) {
          var index, iterable = collection, result2 = iterable;
          if (!iterable) return result2;
          if (!objectTypes[typeof iterable]) return result2;
          callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
          for (index in iterable) {
            if (callback(iterable[index], index, collection) === false) return result2;
          }
          return result2;
        };
        function forInRight(object, callback, thisArg) {
          var pairs2 = [];
          forIn(object, function(value, key) {
            pairs2.push(key, value);
          });
          var length = pairs2.length;
          callback = baseCreateCallback(callback, thisArg, 3);
          while (length--) {
            if (callback(pairs2[length--], pairs2[length], object) === false) {
              break;
            }
          }
          return object;
        }
        var forOwn = function(collection, callback, thisArg) {
          var index, iterable = collection, result2 = iterable;
          if (!iterable) return result2;
          if (!objectTypes[typeof iterable]) return result2;
          callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
          var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
          while (++ownIndex < length) {
            index = ownProps[ownIndex];
            if (callback(iterable[index], index, collection) === false) return result2;
          }
          return result2;
        };
        function forOwnRight(object, callback, thisArg) {
          var props = keys(object), length = props.length;
          callback = baseCreateCallback(callback, thisArg, 3);
          while (length--) {
            var key = props[length];
            if (callback(object[key], key, object) === false) {
              break;
            }
          }
          return object;
        }
        function functions(object) {
          var result2 = [];
          forIn(object, function(value, key) {
            if (isFunction(value)) {
              result2.push(key);
            }
          });
          return result2.sort();
        }
        function has(object, key) {
          return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object) {
          var index = -1, props = keys(object), length = props.length, result2 = {};
          while (++index < length) {
            var key = props[index];
            result2[object[key]] = key;
          }
          return result2;
        }
        function isBoolean(value) {
          return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
        }
        function isDate(value) {
          return value && typeof value == "object" && toString.call(value) == dateClass || false;
        }
        function isElement(value) {
          return value && value.nodeType === 1 || false;
        }
        function isEmpty(value) {
          var result2 = true;
          if (!value) {
            return result2;
          }
          var className = toString.call(value), length = value.length;
          if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
            return !length;
          }
          forOwn(value, function() {
            return result2 = false;
          });
          return result2;
        }
        function isEqual(a, b, callback, thisArg) {
          return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
        }
        function isFinite(value) {
          return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        function isFunction(value) {
          return typeof value == "function";
        }
        function isObject(value) {
          return !!(value && objectTypes[typeof value]);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
          if (!(value && toString.call(value) == objectClass)) {
            return false;
          }
          var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
          return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        };
        function isRegExp(value) {
          return value && typeof value == "object" && toString.call(value) == regexpClass || false;
        }
        function isString(value) {
          return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
        }
        function isUndefined(value) {
          return typeof value == "undefined";
        }
        function mapValues(object, callback, thisArg) {
          var result2 = {};
          callback = lodash.createCallback(callback, thisArg, 3);
          forOwn(object, function(value, key, object2) {
            result2[key] = callback(value, key, object2);
          });
          return result2;
        }
        function merge(object) {
          var args = arguments, length = 2;
          if (!isObject(object)) {
            return object;
          }
          if (typeof args[2] != "number") {
            length = args.length;
          }
          if (length > 3 && typeof args[length - 2] == "function") {
            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
          } else if (length > 2 && typeof args[length - 1] == "function") {
            callback = args[--length];
          }
          var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
          while (++index < length) {
            baseMerge(object, sources[index], callback, stackA, stackB);
          }
          releaseArray(stackA);
          releaseArray(stackB);
          return object;
        }
        function omit(object, callback, thisArg) {
          var result2 = {};
          if (typeof callback != "function") {
            var props = [];
            forIn(object, function(value, key2) {
              props.push(key2);
            });
            props = baseDifference(props, baseFlatten(arguments, true, false, 1));
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              result2[key] = object[key];
            }
          } else {
            callback = lodash.createCallback(callback, thisArg, 3);
            forIn(object, function(value, key2, object2) {
              if (!callback(value, key2, object2)) {
                result2[key2] = value;
              }
            });
          }
          return result2;
        }
        function pairs(object) {
          var index = -1, props = keys(object), length = props.length, result2 = Array2(length);
          while (++index < length) {
            var key = props[index];
            result2[index] = [key, object[key]];
          }
          return result2;
        }
        function pick(object, callback, thisArg) {
          var result2 = {};
          if (typeof callback != "function") {
            var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
            while (++index < length) {
              var key = props[index];
              if (key in object) {
                result2[key] = object[key];
              }
            }
          } else {
            callback = lodash.createCallback(callback, thisArg, 3);
            forIn(object, function(value, key2, object2) {
              if (callback(value, key2, object2)) {
                result2[key2] = value;
              }
            });
          }
          return result2;
        }
        function transform(object, callback, accumulator, thisArg) {
          var isArr = isArray(object);
          if (accumulator == null) {
            if (isArr) {
              accumulator = [];
            } else {
              var ctor = object && object.constructor, proto = ctor && ctor.prototype;
              accumulator = baseCreate(proto);
            }
          }
          if (callback) {
            callback = lodash.createCallback(callback, thisArg, 4);
            (isArr ? forEach : forOwn)(object, function(value, index, object2) {
              return callback(accumulator, value, index, object2);
            });
          }
          return accumulator;
        }
        function values(object) {
          var index = -1, props = keys(object), length = props.length, result2 = Array2(length);
          while (++index < length) {
            result2[index] = object[props[index]];
          }
          return result2;
        }
        function at(collection) {
          var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result2 = Array2(length);
          while (++index < length) {
            result2[index] = collection[props[index]];
          }
          return result2;
        }
        function contains(collection, target, fromIndex) {
          var index = -1, indexOf2 = getIndexOf(), length = collection ? collection.length : 0, result2 = false;
          fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
          if (isArray(collection)) {
            result2 = indexOf2(collection, target, fromIndex) > -1;
          } else if (typeof length == "number") {
            result2 = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf2(collection, target, fromIndex)) > -1;
          } else {
            forOwn(collection, function(value) {
              if (++index >= fromIndex) {
                return !(result2 = value === target);
              }
            });
          }
          return result2;
        }
        var countBy = createAggregator(function(result2, value, key) {
          hasOwnProperty.call(result2, key) ? result2[key]++ : result2[key] = 1;
        });
        function every(collection, callback, thisArg) {
          var result2 = true;
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == "number") {
            while (++index < length) {
              if (!(result2 = !!callback(collection[index], index, collection))) {
                break;
              }
            }
          } else {
            forOwn(collection, function(value, index2, collection2) {
              return result2 = !!callback(value, index2, collection2);
            });
          }
          return result2;
        }
        function filter(collection, callback, thisArg) {
          var result2 = [];
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == "number") {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                result2.push(value);
              }
            }
          } else {
            forOwn(collection, function(value2, index2, collection2) {
              if (callback(value2, index2, collection2)) {
                result2.push(value2);
              }
            });
          }
          return result2;
        }
        function find(collection, callback, thisArg) {
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == "number") {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                return value;
              }
            }
          } else {
            var result2;
            forOwn(collection, function(value2, index2, collection2) {
              if (callback(value2, index2, collection2)) {
                result2 = value2;
                return false;
              }
            });
            return result2;
          }
        }
        function findLast(collection, callback, thisArg) {
          var result2;
          callback = lodash.createCallback(callback, thisArg, 3);
          forEachRight(collection, function(value, index, collection2) {
            if (callback(value, index, collection2)) {
              result2 = value;
              return false;
            }
          });
          return result2;
        }
        function forEach(collection, callback, thisArg) {
          var index = -1, length = collection ? collection.length : 0;
          callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
          if (typeof length == "number") {
            while (++index < length) {
              if (callback(collection[index], index, collection) === false) {
                break;
              }
            }
          } else {
            forOwn(collection, callback);
          }
          return collection;
        }
        function forEachRight(collection, callback, thisArg) {
          var length = collection ? collection.length : 0;
          callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
          if (typeof length == "number") {
            while (length--) {
              if (callback(collection[length], length, collection) === false) {
                break;
              }
            }
          } else {
            var props = keys(collection);
            length = props.length;
            forOwn(collection, function(value, key, collection2) {
              key = props ? props[--length] : --length;
              return callback(collection2[key], key, collection2);
            });
          }
          return collection;
        }
        var groupBy = createAggregator(function(result2, value, key) {
          (hasOwnProperty.call(result2, key) ? result2[key] : result2[key] = []).push(value);
        });
        var indexBy = createAggregator(function(result2, value, key) {
          result2[key] = value;
        });
        function invoke(collection, methodName) {
          var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result2 = Array2(typeof length == "number" ? length : 0);
          forEach(collection, function(value) {
            result2[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
          });
          return result2;
        }
        function map(collection, callback, thisArg) {
          var index = -1, length = collection ? collection.length : 0;
          callback = lodash.createCallback(callback, thisArg, 3);
          if (typeof length == "number") {
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = callback(collection[index], index, collection);
            }
          } else {
            result2 = [];
            forOwn(collection, function(value, key, collection2) {
              result2[++index] = callback(value, key, collection2);
            });
          }
          return result2;
        }
        function max(collection, callback, thisArg) {
          var computed = -Infinity, result2 = computed;
          if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
            callback = null;
          }
          if (callback == null && isArray(collection)) {
            var index = -1, length = collection.length;
            while (++index < length) {
              var value = collection[index];
              if (value > result2) {
                result2 = value;
              }
            }
          } else {
            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
            forEach(collection, function(value2, index2, collection2) {
              var current = callback(value2, index2, collection2);
              if (current > computed) {
                computed = current;
                result2 = value2;
              }
            });
          }
          return result2;
        }
        function min(collection, callback, thisArg) {
          var computed = Infinity, result2 = computed;
          if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
            callback = null;
          }
          if (callback == null && isArray(collection)) {
            var index = -1, length = collection.length;
            while (++index < length) {
              var value = collection[index];
              if (value < result2) {
                result2 = value;
              }
            }
          } else {
            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
            forEach(collection, function(value2, index2, collection2) {
              var current = callback(value2, index2, collection2);
              if (current < computed) {
                computed = current;
                result2 = value2;
              }
            });
          }
          return result2;
        }
        var pluck = map;
        function reduce(collection, callback, accumulator, thisArg) {
          if (!collection) return accumulator;
          var noaccum = arguments.length < 3;
          callback = lodash.createCallback(callback, thisArg, 4);
          var index = -1, length = collection.length;
          if (typeof length == "number") {
            if (noaccum) {
              accumulator = collection[++index];
            }
            while (++index < length) {
              accumulator = callback(accumulator, collection[index], index, collection);
            }
          } else {
            forOwn(collection, function(value, index2, collection2) {
              accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index2, collection2);
            });
          }
          return accumulator;
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
          var noaccum = arguments.length < 3;
          callback = lodash.createCallback(callback, thisArg, 4);
          forEachRight(collection, function(value, index, collection2) {
            accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function reject(collection, callback, thisArg) {
          callback = lodash.createCallback(callback, thisArg, 3);
          return filter(collection, function(value, index, collection2) {
            return !callback(value, index, collection2);
          });
        }
        function sample(collection, n, guard) {
          if (collection && typeof collection.length != "number") {
            collection = values(collection);
          }
          if (n == null || guard) {
            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined2;
          }
          var result2 = shuffle(collection);
          result2.length = nativeMin(nativeMax(0, n), result2.length);
          return result2;
        }
        function shuffle(collection) {
          var index = -1, length = collection ? collection.length : 0, result2 = Array2(typeof length == "number" ? length : 0);
          forEach(collection, function(value) {
            var rand = baseRandom(0, ++index);
            result2[index] = result2[rand];
            result2[rand] = value;
          });
          return result2;
        }
        function size(collection) {
          var length = collection ? collection.length : 0;
          return typeof length == "number" ? length : keys(collection).length;
        }
        function some(collection, callback, thisArg) {
          var result2;
          callback = lodash.createCallback(callback, thisArg, 3);
          var index = -1, length = collection ? collection.length : 0;
          if (typeof length == "number") {
            while (++index < length) {
              if (result2 = callback(collection[index], index, collection)) {
                break;
              }
            }
          } else {
            forOwn(collection, function(value, index2, collection2) {
              return !(result2 = callback(value, index2, collection2));
            });
          }
          return !!result2;
        }
        function sortBy(collection, callback, thisArg) {
          var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result2 = Array2(typeof length == "number" ? length : 0);
          if (!isArr) {
            callback = lodash.createCallback(callback, thisArg, 3);
          }
          forEach(collection, function(value, key, collection2) {
            var object2 = result2[++index] = getObject();
            if (isArr) {
              object2.criteria = map(callback, function(key2) {
                return value[key2];
              });
            } else {
              (object2.criteria = getArray())[0] = callback(value, key, collection2);
            }
            object2.index = index;
            object2.value = value;
          });
          length = result2.length;
          result2.sort(compareAscending);
          while (length--) {
            var object = result2[length];
            result2[length] = object.value;
            if (!isArr) {
              releaseArray(object.criteria);
            }
            releaseObject(object);
          }
          return result2;
        }
        function toArray(collection) {
          if (collection && typeof collection.length == "number") {
            return slice(collection);
          }
          return values(collection);
        }
        var where = filter;
        function compact(array) {
          var index = -1, length = array ? array.length : 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2.push(value);
            }
          }
          return result2;
        }
        function difference(array) {
          return baseDifference(array, baseFlatten(arguments, true, true, 1));
        }
        function findIndex(array, callback, thisArg) {
          var index = -1, length = array ? array.length : 0;
          callback = lodash.createCallback(callback, thisArg, 3);
          while (++index < length) {
            if (callback(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function findLastIndex(array, callback, thisArg) {
          var length = array ? array.length : 0;
          callback = lodash.createCallback(callback, thisArg, 3);
          while (length--) {
            if (callback(array[length], length, array)) {
              return length;
            }
          }
          return -1;
        }
        function first(array, callback, thisArg) {
          var n = 0, length = array ? array.length : 0;
          if (typeof callback != "number" && callback != null) {
            var index = -1;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback;
            if (n == null || thisArg) {
              return array ? array[0] : undefined2;
            }
          }
          return slice(array, 0, nativeMin(nativeMax(0, n), length));
        }
        function flatten(array, isShallow, callback, thisArg) {
          if (typeof isShallow != "boolean" && isShallow != null) {
            thisArg = callback;
            callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
            isShallow = false;
          }
          if (callback != null) {
            array = map(array, callback, thisArg);
          }
          return baseFlatten(array, isShallow);
        }
        function indexOf(array, value, fromIndex) {
          if (typeof fromIndex == "number") {
            var length = array ? array.length : 0;
            fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
          } else if (fromIndex) {
            var index = sortedIndex(array, value);
            return array[index] === value ? index : -1;
          }
          return baseIndexOf(array, value, fromIndex);
        }
        function initial(array, callback, thisArg) {
          var n = 0, length = array ? array.length : 0;
          if (typeof callback != "number" && callback != null) {
            var index = length;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (index-- && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback == null || thisArg ? 1 : callback || n;
          }
          return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        function intersection() {
          var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf2 = getIndexOf(), trustIndexOf = indexOf2 === baseIndexOf, seen = getArray();
          while (++argsIndex < argsLength) {
            var value = arguments[argsIndex];
            if (isArray(value) || isArguments(value)) {
              args.push(value);
              caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
            }
          }
          var array = args[0], index = -1, length = array ? array.length : 0, result2 = [];
          outer:
            while (++index < length) {
              var cache = caches[0];
              value = array[index];
              if ((cache ? cacheIndexOf(cache, value) : indexOf2(seen, value)) < 0) {
                argsIndex = argsLength;
                (cache || seen).push(value);
                while (--argsIndex) {
                  cache = caches[argsIndex];
                  if ((cache ? cacheIndexOf(cache, value) : indexOf2(args[argsIndex], value)) < 0) {
                    continue outer;
                  }
                }
                result2.push(value);
              }
            }
          while (argsLength--) {
            cache = caches[argsLength];
            if (cache) {
              releaseObject(cache);
            }
          }
          releaseArray(caches);
          releaseArray(seen);
          return result2;
        }
        function last(array, callback, thisArg) {
          var n = 0, length = array ? array.length : 0;
          if (typeof callback != "number" && callback != null) {
            var index = length;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (index-- && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback;
            if (n == null || thisArg) {
              return array ? array[length - 1] : undefined2;
            }
          }
          return slice(array, nativeMax(0, length - n));
        }
        function lastIndexOf(array, value, fromIndex) {
          var index = array ? array.length : 0;
          if (typeof fromIndex == "number") {
            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull(array) {
          var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
          while (++argsIndex < argsLength) {
            var index = -1, value = args[argsIndex];
            while (++index < length) {
              if (array[index] === value) {
                splice.call(array, index--, 1);
                length--;
              }
            }
          }
          return array;
        }
        function range(start, end, step) {
          start = +start || 0;
          step = typeof step == "number" ? step : +step || 1;
          if (end == null) {
            end = start;
            start = 0;
          }
          var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result2 = Array2(length);
          while (++index < length) {
            result2[index] = start;
            start += step;
          }
          return result2;
        }
        function remove(array, callback, thisArg) {
          var index = -1, length = array ? array.length : 0, result2 = [];
          callback = lodash.createCallback(callback, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (callback(value, index, array)) {
              result2.push(value);
              splice.call(array, index--, 1);
              length--;
            }
          }
          return result2;
        }
        function rest(array, callback, thisArg) {
          if (typeof callback != "number" && callback != null) {
            var n = 0, index = -1, length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback == null || thisArg ? 1 : nativeMax(0, callback);
          }
          return slice(array, n);
        }
        function sortedIndex(array, value, callback, thisArg) {
          var low = 0, high = array ? array.length : low;
          callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
          value = callback(value);
          while (low < high) {
            var mid = low + high >>> 1;
            callback(array[mid]) < value ? low = mid + 1 : high = mid;
          }
          return low;
        }
        function union() {
          return baseUniq(baseFlatten(arguments, true, true));
        }
        function uniq(array, isSorted, callback, thisArg) {
          if (typeof isSorted != "boolean" && isSorted != null) {
            thisArg = callback;
            callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
            isSorted = false;
          }
          if (callback != null) {
            callback = lodash.createCallback(callback, thisArg, 3);
          }
          return baseUniq(array, isSorted, callback);
        }
        function without(array) {
          return baseDifference(array, slice(arguments, 1));
        }
        function xor() {
          var index = -1, length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArray(array) || isArguments(array)) {
              var result2 = result2 ? baseUniq(baseDifference(result2, array).concat(baseDifference(array, result2))) : array;
            }
          }
          return result2 || [];
        }
        function zip() {
          var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result2 = Array2(length < 0 ? 0 : length);
          while (++index < length) {
            result2[index] = pluck(array, index);
          }
          return result2;
        }
        function zipObject(keys2, values2) {
          var index = -1, length = keys2 ? keys2.length : 0, result2 = {};
          if (!values2 && length && !isArray(keys2[0])) {
            values2 = [];
          }
          while (++index < length) {
            var key = keys2[index];
            if (values2) {
              result2[key] = values2[index];
            } else if (key) {
              result2[key[0]] = key[1];
            }
          }
          return result2;
        }
        function after(n, func) {
          if (!isFunction(func)) {
            throw new TypeError();
          }
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function bind(func, thisArg) {
          return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
        }
        function bindAll(object) {
          var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
          while (++index < length) {
            var key = funcs[index];
            object[key] = createWrapper(object[key], 1, null, null, object);
          }
          return object;
        }
        function bindKey(object, key) {
          return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
        }
        function compose() {
          var funcs = arguments, length = funcs.length;
          while (length--) {
            if (!isFunction(funcs[length])) {
              throw new TypeError();
            }
          }
          return function() {
            var args = arguments, length2 = funcs.length;
            while (length2--) {
              args = [funcs[length2].apply(this, args)];
            }
            return args[0];
          };
        }
        function curry(func, arity) {
          arity = typeof arity == "number" ? arity : +arity || func.length;
          return createWrapper(func, 4, null, null, null, arity);
        }
        function debounce(func, wait, options) {
          var args, maxTimeoutId, result2, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
          if (!isFunction(func)) {
            throw new TypeError();
          }
          wait = nativeMax(0, wait) || 0;
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = options.leading;
            maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
            trailing = "trailing" in options ? options.trailing : trailing;
          }
          var delayed = function() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0) {
              if (maxTimeoutId) {
                clearTimeout2(maxTimeoutId);
              }
              var isCalled = trailingCall;
              maxTimeoutId = timeoutId = trailingCall = undefined2;
              if (isCalled) {
                lastCalled = now();
                result2 = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            } else {
              timeoutId = setTimeout2(delayed, remaining);
            }
          };
          var maxDelayed = function() {
            if (timeoutId) {
              clearTimeout2(timeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined2;
            if (trailing || maxWait !== wait) {
              lastCalled = now();
              result2 = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
            }
          };
          return function() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout2(maxTimeoutId);
                }
                lastCalled = stamp;
                result2 = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout2(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout2(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout2(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result2 = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
            return result2;
          };
        }
        function defer(func) {
          if (!isFunction(func)) {
            throw new TypeError();
          }
          var args = slice(arguments, 1);
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, 1);
        }
        function delay(func, wait) {
          if (!isFunction(func)) {
            throw new TypeError();
          }
          var args = slice(arguments, 2);
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function memoize(func, resolver) {
          if (!isFunction(func)) {
            throw new TypeError();
          }
          var memoized = function() {
            var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
            return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
          };
          memoized.cache = {};
          return memoized;
        }
        function once(func) {
          var ran, result2;
          if (!isFunction(func)) {
            throw new TypeError();
          }
          return function() {
            if (ran) {
              return result2;
            }
            ran = true;
            result2 = func.apply(this, arguments);
            func = null;
            return result2;
          };
        }
        function partial(func) {
          return createWrapper(func, 16, slice(arguments, 1));
        }
        function partialRight(func) {
          return createWrapper(func, 32, null, slice(arguments, 1));
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (!isFunction(func)) {
            throw new TypeError();
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = "leading" in options ? options.leading : leading;
            trailing = "trailing" in options ? options.trailing : trailing;
          }
          debounceOptions.leading = leading;
          debounceOptions.maxWait = wait;
          debounceOptions.trailing = trailing;
          return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
          return createWrapper(wrapper, 16, [value]);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function createCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (func == null || type == "function") {
            return baseCreateCallback(func, thisArg, argCount);
          }
          if (type != "object") {
            return property(func);
          }
          var props = keys(func), key = props[0], a = func[key];
          if (props.length == 1 && a === a && !isObject(a)) {
            return function(object) {
              var b = object[key];
              return a === b && (a !== 0 || 1 / a == 1 / b);
            };
          }
          return function(object) {
            var length = props.length, result2 = false;
            while (length--) {
              if (!(result2 = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                break;
              }
            }
            return result2;
          };
        }
        function escape(string) {
          return string == null ? "" : String2(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        function identity(value) {
          return value;
        }
        function mixin(object, source, options) {
          var chain2 = true, methodNames = source && functions(source);
          if (!source || !options && !methodNames.length) {
            if (options == null) {
              options = source;
            }
            ctor = lodashWrapper;
            source = object;
            object = lodash;
            methodNames = functions(source);
          }
          if (options === false) {
            chain2 = false;
          } else if (isObject(options) && "chain" in options) {
            chain2 = options.chain;
          }
          var ctor = object, isFunc = isFunction(ctor);
          forEach(methodNames, function(methodName) {
            var func = object[methodName] = source[methodName];
            if (isFunc) {
              ctor.prototype[methodName] = function() {
                var chainAll = this.__chain__, value = this.__wrapped__, args = [value];
                push.apply(args, arguments);
                var result2 = func.apply(object, args);
                if (chain2 || chainAll) {
                  if (value === result2 && isObject(result2)) {
                    return this;
                  }
                  result2 = new ctor(result2);
                  result2.__chain__ = chainAll;
                }
                return result2;
              };
            }
          });
        }
        function noConflict() {
          context._ = oldDash;
          return this;
        }
        function noop() {
        }
        var now = isNative(now = Date2.now) && now || function() {
          return new Date2().getTime();
        };
        var parseInt2 = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
          return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
        };
        function property(key) {
          return function(object) {
            return object[key];
          };
        }
        function random(min2, max2, floating) {
          var noMin = min2 == null, noMax = max2 == null;
          if (floating == null) {
            if (typeof min2 == "boolean" && noMax) {
              floating = min2;
              min2 = 1;
            } else if (!noMax && typeof max2 == "boolean") {
              floating = max2;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max2 = 1;
          }
          min2 = +min2 || 0;
          if (noMax) {
            max2 = min2;
            min2 = 0;
          } else {
            max2 = +max2 || 0;
          }
          if (floating || min2 % 1 || max2 % 1) {
            var rand = nativeRandom();
            return nativeMin(min2 + rand * (max2 - min2 + parseFloat("1e-" + ((rand + "").length - 1))), max2);
          }
          return baseRandom(min2, max2);
        }
        function result(object, key) {
          if (object) {
            var value = object[key];
            return isFunction(value) ? object[key]() : value;
          }
        }
        function template(text, data, options) {
          var settings = lodash.templateSettings;
          text = String2(text || "");
          options = defaults({}, options, settings);
          var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
          var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable, hasVariable = variable;
          if (!hasVariable) {
            variable = "obj";
            source = "with (" + variable + ") {\n" + source + "\n}\n";
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
          try {
            var result2 = Function(importsKeys, "return " + source + sourceURL).apply(undefined2, importsValues);
          } catch (e) {
            e.source = source;
            throw e;
          }
          if (data) {
            return result2(data);
          }
          result2.source = source;
          return result2;
        }
        function times(n, callback, thisArg) {
          n = (n = +n) > -1 ? n : 0;
          var index = -1, result2 = Array2(n);
          callback = baseCreateCallback(callback, thisArg, 1);
          while (++index < n) {
            result2[index] = callback(index);
          }
          return result2;
        }
        function unescape(string) {
          return string == null ? "" : String2(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return String2(prefix == null ? "" : prefix) + id;
        }
        function chain(value) {
          value = new lodashWrapper(value);
          value.__chain__ = true;
          return value;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function wrapperChain() {
          this.__chain__ = true;
          return this;
        }
        function wrapperToString() {
          return String2(this.__wrapped__);
        }
        function wrapperValueOf() {
          return this.__wrapped__;
        }
        lodash.after = after;
        lodash.assign = assign;
        lodash.at = at;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.chain = chain;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.createCallback = createCallback;
        lodash.curry = curry;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.pull = pull;
        lodash.range = range;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        lodash.unzip = zip;
        mixin(lodash);
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
        mixin(function() {
          var source = {};
          forOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }(), false);
        lodash.first = first;
        lodash.last = last;
        lodash.sample = sample;
        lodash.take = first;
        lodash.head = first;
        forOwn(lodash, function(func, methodName) {
          var callbackable = methodName !== "sample";
          if (!lodash.prototype[methodName]) {
            lodash.prototype[methodName] = function(n, guard) {
              var chainAll = this.__chain__, result2 = func(this.__wrapped__, n, guard);
              return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result2 : new lodashWrapper(result2, chainAll);
            };
          }
        });
        lodash.VERSION = "2.4.2";
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.value = wrapperValueOf;
        lodash.prototype.valueOf = wrapperValueOf;
        forEach(["join", "pop", "shift"], function(methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function() {
            var chainAll = this.__chain__, result2 = func.apply(this.__wrapped__, arguments);
            return chainAll ? new lodashWrapper(result2, chainAll) : result2;
          };
        });
        forEach(["push", "reverse", "sort", "unshift"], function(methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function() {
            func.apply(this.__wrapped__, arguments);
            return this;
          };
        });
        forEach(["concat", "slice", "splice"], function(methodName) {
          var func = arrayRef[methodName];
          lodash.prototype[methodName] = function() {
            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
          };
        });
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/quilljs/package.json
var require_package = __commonJS({
  "node_modules/quilljs/package.json"(exports, module) {
    module.exports = {
      name: "quilljs",
      version: "0.18.1",
      description: "Cross browser rich text editor",
      author: "Jason Chen <jhchen7@gmail.com>",
      homepage: "http://quilljs.com",
      contributors: [
        "Byron Milligan <byronner@gmail.com>",
        "Keegan Poppen <keegan.poppen@gmail.com>"
      ],
      main: "index.js",
      dependencies: {
        eventemitter2: "~0.4.13",
        lodash: "~2.4.1",
        "rich-text": "~1.0.2"
      },
      devDependencies: {
        async: "~0.9.0",
        "coffee-script": "~1.8.0",
        coffeeify: "~0.7.0",
        glob: "~4.0.4",
        grunt: "~0.4.3",
        "grunt-browserify": "~2.1.0",
        "grunt-contrib-clean": "~0.6.0",
        "grunt-contrib-coffee": "~0.12.0",
        "grunt-contrib-compress": "~0.12.0",
        "grunt-contrib-concat": "~0.5.0",
        "grunt-contrib-connect": "~0.8.0",
        "grunt-contrib-copy": "~0.7.0",
        "grunt-contrib-stylus": "~0.18.0",
        "grunt-contrib-uglify": "~0.6.0",
        "grunt-karma": "~0.9.0",
        "grunt-lodash": "~0.3.0",
        "grunt-protractor-runner": "~1.1.0",
        "grunt-sauce-connect-launcher": "~0.3.0",
        harp: "~0.14.0",
        istanbul: "~0.3.0",
        jquery: "~2.1.1",
        karma: "~0.12.0",
        "karma-chrome-launcher": "~0.1.2",
        "karma-coffee-preprocessor": "~0.2.1",
        "karma-coverage": "~0.2.0",
        "karma-firefox-launcher": "~0.1.3",
        "karma-html2js-preprocessor": "~0.1.0",
        "karma-jasmine": "~0.2.0",
        "karma-phantomjs-launcher": "~0.1.2",
        "karma-safari-launcher": "~0.1.1",
        "karma-sauce-launcher": "~0.2.2",
        "load-grunt-tasks": "~0.6.0",
        protractor: "~1.3.1",
        stylus: "~0.49.2",
        watchify: "~0.10.2"
      },
      engines: {
        node: ">=0.10"
      },
      license: "BSD-3-Clause",
      repository: {
        type: "git",
        url: "https://github.com/quilljs/quill"
      },
      bugs: {
        url: "https://github.com/quilljs/quill/issues"
      },
      scripts: {
        prepublish: "grunt coffee:quill",
        postpublish: "grunt clean:coffee",
        test: "grunt test"
      },
      keywords: [
        "editor",
        "rich text",
        "wysiwyg"
      ]
    };
  }
});

// node_modules/fast-diff/diff.js
var require_diff = __commonJS({
  "node_modules/fast-diff/diff.js"(exports, module) {
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2) {
      if (text1 == text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs);
      return diffs;
    }
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i != -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length == 1) {
        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 != 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
    }
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    }
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    }
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
          var prefixLength = diff_commonPrefix(
            longtext2.substring(i),
            shorttext2.substring(j)
          );
          var suffixLength = diff_commonSuffix(
            longtext2.substring(0, i),
            shorttext2.substring(0, j)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 4)
      );
      var hm2 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 2)
      );
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    function diff_cleanupMerge(diffs) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            if (count_delete + count_insert > 1) {
              if (count_delete !== 0 && count_insert !== 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                    diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, [
                      DIFF_EQUAL,
                      text_insert.substring(0, commonlength)
                    ]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              if (count_delete === 0) {
                diffs.splice(
                  pointer - count_insert,
                  count_delete + count_insert,
                  [DIFF_INSERT, text_insert]
                );
              } else if (count_insert === 0) {
                diffs.splice(
                  pointer - count_delete,
                  count_delete + count_insert,
                  [DIFF_DELETE, text_delete]
                );
              } else {
                diffs.splice(
                  pointer - count_delete - count_insert,
                  count_delete + count_insert,
                  [DIFF_DELETE, text_delete],
                  [DIFF_INSERT, text_insert]
                );
              }
              pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs);
      }
    }
    var diff = diff_main;
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;
    module.exports = diff;
  }
});

// node_modules/rich-text/lib/is.js
var require_is = __commonJS({
  "node_modules/rich-text/lib/is.js"(exports, module) {
    module.exports = {
      equal: function(a, b) {
        if (a === b) return true;
        if (a == null && b == null) return true;
        if (a == null || b == null) return false;
        if (Object.keys(a).length != Object.keys(b).length) return false;
        for (var key in a) {
          if (a[key] !== b[key]) return false;
        }
        return true;
      },
      array: function(value) {
        return Array.isArray(value);
      },
      number: function(value) {
        if (typeof value === "number") return true;
        if (typeof value === "object" && Object.prototype.toString.call(value) === "[object Number]") return true;
        return false;
      },
      object: function(value) {
        if (!value) return false;
        return typeof value === "function" || typeof value === "object";
      },
      string: function(value) {
        if (typeof value === "string") return true;
        if (typeof value === "object" && Object.prototype.toString.call(value) === "[object String]") return true;
        return false;
      }
    };
  }
});

// node_modules/rich-text/lib/op.js
var require_op = __commonJS({
  "node_modules/rich-text/lib/op.js"(exports, module) {
    var is = require_is();
    var lib = {
      attributes: {
        clone: function(attributes, keepNull) {
          if (!is.object(attributes)) return {};
          return Object.keys(attributes).reduce(function(memo, key) {
            if (attributes[key] !== void 0 && (attributes[key] !== null || keepNull)) {
              memo[key] = attributes[key];
            }
            return memo;
          }, {});
        },
        compose: function(a, b, keepNull) {
          if (!is.object(a)) a = {};
          if (!is.object(b)) b = {};
          var attributes = this.clone(b, keepNull);
          for (var key in a) {
            if (a[key] !== void 0 && b[key] === void 0) {
              attributes[key] = a[key];
            }
          }
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        },
        diff: function(a, b) {
          if (!is.object(a)) a = {};
          if (!is.object(b)) b = {};
          var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function(attributes2, key) {
            if (a[key] !== b[key]) {
              attributes2[key] = b[key] === void 0 ? null : b[key];
            }
            return attributes2;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        },
        transform: function(a, b, priority) {
          if (!is.object(a)) return b;
          if (!is.object(b)) return void 0;
          if (!priority) return b;
          var attributes = Object.keys(b).reduce(function(attributes2, key) {
            if (a[key] === void 0) attributes2[key] = b[key];
            return attributes2;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        }
      },
      clone: function(op) {
        var newOp = this.attributes.clone(op);
        if (is.object(newOp.attributes)) {
          newOp.attributes = this.attributes.clone(newOp.attributes, true);
        }
        return newOp;
      },
      iterator: function(ops) {
        return new Iterator(ops);
      },
      length: function(op) {
        if (is.number(op["delete"])) {
          return op["delete"];
        } else if (is.number(op.retain)) {
          return op.retain;
        } else {
          return is.string(op.insert) ? op.insert.length : 1;
        }
      }
    };
    function Iterator(ops) {
      this.ops = ops;
      this.index = 0;
      this.offset = 0;
    }
    Iterator.prototype.hasNext = function() {
      return this.peekLength() < Infinity;
    };
    Iterator.prototype.next = function(length) {
      if (!length) length = Infinity;
      var nextOp = this.ops[this.index];
      if (nextOp) {
        var offset = this.offset;
        var opLength = lib.length(nextOp);
        if (length >= opLength - offset) {
          length = opLength - offset;
          this.index += 1;
          this.offset = 0;
        } else {
          this.offset += length;
        }
        if (is.number(nextOp["delete"])) {
          return { "delete": length };
        } else {
          var retOp = {};
          if (nextOp.attributes) {
            retOp.attributes = nextOp.attributes;
          }
          if (is.number(nextOp.retain)) {
            retOp.retain = length;
          } else if (is.string(nextOp.insert)) {
            retOp.insert = nextOp.insert.substr(offset, length);
          } else {
            retOp.insert = nextOp.insert;
          }
          return retOp;
        }
      } else {
        return { retain: Infinity };
      }
    };
    Iterator.prototype.peekLength = function() {
      if (this.ops[this.index]) {
        return lib.length(this.ops[this.index]) - this.offset;
      } else {
        return Infinity;
      }
    };
    Iterator.prototype.peekType = function() {
      if (this.ops[this.index]) {
        if (is.number(this.ops[this.index]["delete"])) {
          return "delete";
        } else if (is.number(this.ops[this.index].retain)) {
          return "retain";
        } else {
          return "insert";
        }
      }
      return "retain";
    };
    module.exports = lib;
  }
});

// node_modules/rich-text/lib/delta.js
var require_delta = __commonJS({
  "node_modules/rich-text/lib/delta.js"(exports, module) {
    var diff = require_diff();
    var is = require_is();
    var op = require_op();
    var NULL_CHARACTER = String.fromCharCode(0);
    var Delta = function(ops) {
      if (is.array(ops)) {
        this.ops = ops;
      } else if (is.object(ops) && is.array(ops.ops)) {
        this.ops = ops.ops;
      } else {
        this.ops = [];
      }
    };
    Delta.prototype.insert = function(text, attributes) {
      var newOp = {};
      if (is.string(text)) {
        if (text.length === 0) return this;
        newOp.insert = text;
      } else if (is.number(text)) {
        newOp.insert = text;
      }
      if (is.object(attributes) && Object.keys(attributes).length > 0) newOp.attributes = attributes;
      return this.push(newOp);
    };
    Delta.prototype["delete"] = function(length) {
      if (length <= 0) return this;
      return this.push({ "delete": length });
    };
    Delta.prototype.retain = function(length, attributes) {
      if (length <= 0) return this;
      var newOp = { retain: length };
      if (is.object(attributes) && Object.keys(attributes).length > 0) newOp.attributes = attributes;
      return this.push(newOp);
    };
    Delta.prototype.push = function(newOp) {
      var index = this.ops.length;
      var lastOp = this.ops[index - 1];
      newOp = op.clone(newOp);
      if (is.object(lastOp)) {
        if (is.number(newOp["delete"]) && is.number(lastOp["delete"])) {
          this.ops[index - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
          return this;
        }
        if (is.number(lastOp["delete"]) && (is.string(newOp.insert) || is.number(newOp.insert))) {
          index -= 1;
          lastOp = this.ops[index - 1];
          if (!is.object(lastOp)) {
            this.ops.unshift(newOp);
            return this;
          }
        }
        if (is.equal(newOp.attributes, lastOp.attributes)) {
          if (is.string(newOp.insert) && is.string(lastOp.insert)) {
            this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
            if (is.object(newOp.attributes)) this.ops[index - 1].attributes = newOp.attributes;
            return this;
          } else if (is.number(newOp.retain) && is.number(lastOp.retain)) {
            this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
            if (is.object(newOp.attributes)) this.ops[index - 1].attributes = newOp.attributes;
            return this;
          }
        }
      }
      this.ops.splice(index, 0, newOp);
      return this;
    };
    Delta.prototype.chop = function() {
      var lastOp = this.ops[this.ops.length - 1];
      if (lastOp && lastOp.retain && !lastOp.attributes) {
        this.ops.pop();
      }
      return this;
    };
    Delta.prototype.length = function() {
      return this.ops.reduce(function(length, elem) {
        return length + op.length(elem);
      }, 0);
    };
    Delta.prototype.slice = function(start, end) {
      start = start || 0;
      if (!is.number(end)) end = Infinity;
      var delta = new Delta();
      var iter = op.iterator(this.ops);
      var index = 0;
      while (index < end && iter.hasNext()) {
        var nextOp;
        if (index < start) {
          nextOp = iter.next(start - index);
        } else {
          nextOp = iter.next(end - index);
          delta.push(nextOp);
        }
        index += op.length(nextOp);
      }
      return delta;
    };
    Delta.prototype.compose = function(other) {
      var thisIter = op.iterator(this.ops);
      var otherIter = op.iterator(other.ops);
      this.ops = [];
      while (thisIter.hasNext() || otherIter.hasNext()) {
        if (otherIter.peekType() === "insert") {
          this.push(otherIter.next());
        } else if (thisIter.peekType() === "delete") {
          this.push(thisIter.next());
        } else {
          var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
          var thisOp = thisIter.next(length);
          var otherOp = otherIter.next(length);
          if (is.number(otherOp.retain)) {
            var newOp = {};
            if (is.number(thisOp.retain)) {
              newOp.retain = length;
            } else {
              newOp.insert = thisOp.insert;
            }
            var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, is.number(thisOp.retain));
            if (attributes) newOp.attributes = attributes;
            this.push(newOp);
          } else if (is.number(otherOp["delete"]) && is.number(thisOp.retain)) {
            this.push(otherOp);
          }
        }
      }
      return this.chop();
    };
    Delta.prototype.diff = function(other) {
      var strings = [this.ops, other.ops].map(function(ops) {
        return ops.map(function(op2) {
          if (is.string(op2.insert)) return op2.insert;
          if (is.number(op2.insert)) return NULL_CHARACTER;
          var prep = ops === other.ops ? "on" : "with";
          throw new Error("diff() called " + prep + " non-document");
        }).join("");
      });
      var diffResult = diff(strings[0], strings[1]);
      var thisIter = op.iterator(this.ops);
      var otherIter = op.iterator(other.ops);
      var delta = new Delta();
      diffResult.forEach(function(component) {
        var length = component[1].length;
        while (length > 0) {
          var opLength = 0;
          switch (component[0]) {
            case diff.INSERT:
              opLength = Math.min(otherIter.peekLength(), length);
              delta.push(otherIter.next(opLength));
              break;
            case diff.DELETE:
              opLength = Math.min(length, thisIter.peekLength());
              thisIter.next(opLength);
              delta["delete"](opLength);
              break;
            case diff.EQUAL:
              opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
              var thisOp = thisIter.next(opLength);
              var otherOp = otherIter.next(opLength);
              if (thisOp.insert === otherOp.insert) {
                delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
              } else {
                delta.push(otherOp)["delete"](opLength);
              }
              break;
          }
          length -= opLength;
        }
      });
      return delta.chop();
    };
    Delta.prototype.transform = function(other, priority) {
      priority = !!priority;
      if (is.number(other)) {
        return this.transformPosition(other, priority);
      }
      var thisIter = op.iterator(this.ops);
      var otherIter = op.iterator(other.ops);
      var delta = new Delta();
      while (thisIter.hasNext() || otherIter.hasNext()) {
        if (thisIter.peekType() === "insert" && (priority || otherIter.peekType() !== "insert")) {
          delta.retain(op.length(thisIter.next()));
        } else if (otherIter.peekType() === "insert") {
          delta.push(otherIter.next());
        } else {
          var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
          var thisOp = thisIter.next(length);
          var otherOp = otherIter.next(length);
          if (thisOp["delete"]) {
            continue;
          } else if (otherOp["delete"]) {
            delta.push(otherOp);
          } else {
            delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
          }
        }
      }
      return delta.chop();
    };
    Delta.prototype.transformPosition = function(index, priority) {
      priority = !!priority;
      var thisIter = op.iterator(this.ops);
      var offset = 0;
      while (thisIter.hasNext() && offset <= index) {
        var length = thisIter.peekLength();
        var nextType = thisIter.peekType();
        thisIter.next();
        if (nextType === "delete") {
          index -= Math.min(length, index - offset);
          continue;
        } else if (nextType === "insert" && (offset < index || !priority)) {
          index += length;
        }
        offset += length;
      }
      return index;
    };
    module.exports = Delta;
  }
});

// node_modules/rich-text/package.json
var require_package2 = __commonJS({
  "node_modules/rich-text/package.json"(exports, module) {
    module.exports = {
      name: "rich-text",
      version: "1.0.3",
      description: "Format for representing rich text documents and changes.",
      author: "Jason Chen <jhchen7@gmail.com>",
      homepage: "https://github.com/ottypes/rich-text",
      main: "index.js",
      dependencies: {
        "fast-diff": "~1.0.0"
      },
      devDependencies: {
        chai: "~1.9.1",
        coveralls: "~2.11.1",
        grunt: "~0.4.5",
        istanbul: "~0.3.0",
        lodash: "~2.4.1",
        mocha: "~1.21.4",
        "ot-fuzzer": "~1.0.0"
      },
      engines: {
        node: ">=0.10"
      },
      license: "MIT",
      scripts: {
        test: "grunt test"
      },
      repository: {
        type: "git",
        url: "https://github.com/ottypes/rich-text"
      },
      bugs: {
        url: "https://github.com/ottypes/rich-text/issues"
      },
      keywords: [
        "rich text",
        "ot",
        "operational transform",
        "delta"
      ]
    };
  }
});

// node_modules/rich-text/lib/type.js
var require_type = __commonJS({
  "node_modules/rich-text/lib/type.js"(exports, module) {
    var Delta = require_delta();
    var pkg = require_package2();
    module.exports = {
      Delta,
      name: "rich-text",
      uri: "http://sharejs.org/types/rich-text/v1",
      create: function(initial) {
        return new Delta(initial);
      },
      apply: function(snapshot, delta) {
        snapshot = new Delta(snapshot);
        delta = new Delta(delta);
        return snapshot.compose(delta);
      },
      compose: function(delta1, delta2) {
        delta1 = new Delta(delta1);
        delta2 = new Delta(delta2);
        return delta1.compose(delta2);
      },
      diff: function(delta1, delta2) {
        delta1 = new Delta(delta1);
        delta2 = new Delta(delta2);
        return delta1.diff(delta2);
      },
      transform: function(delta1, delta2, side) {
        delta1 = new Delta(delta1);
        delta2 = new Delta(delta2);
        return delta2.transform(delta1, side === "left");
      }
    };
  }
});

// node_modules/rich-text/index.js
var require_rich_text = __commonJS({
  "node_modules/rich-text/index.js"(exports, module) {
    module.exports = require_type();
  }
});

// node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS({
  "node_modules/eventemitter2/lib/eventemitter2.js"(exports) {
    !function(undefined2) {
      var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      function init() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          conf.maxListeners && (this._events.maxListeners = conf.maxListeners);
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this.newListener = conf.newListener);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        }
      }
      function EventEmitter(conf) {
        this._events = {};
        this.newListener = false;
        configure.call(this, conf);
      }
      function searchListenerTree(handlers, type, tree, i) {
        if (!tree) {
          return [];
        }
        var listeners = [], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached, typeLength = type.length, currentType = type[i], nextType = type[i + 1];
        if (i === typeLength && tree._listeners) {
          if (typeof tree._listeners === "function") {
            handlers && handlers.push(tree._listeners);
            return [tree];
          } else {
            for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
              handlers && handlers.push(tree._listeners[leaf]);
            }
            return [tree];
          }
        }
        if (currentType === "*" || currentType === "**" || tree[currentType]) {
          if (currentType === "*") {
            for (branch in tree) {
              if (branch !== "_listeners" && tree.hasOwnProperty(branch)) {
                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 1));
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
            }
            for (branch in tree) {
              if (branch !== "_listeners" && tree.hasOwnProperty(branch)) {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
                  }
                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
                } else if (branch === nextType) {
                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 2));
                } else {
                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
                }
              }
            }
            return listeners;
          }
          listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i + 1));
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type, xTree, i + 1);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type, xxTree, typeLength);
            }
            for (branch in xxTree) {
              if (branch !== "_listeners" && xxTree.hasOwnProperty(branch)) {
                if (branch === nextType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 2);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type, xxTree[branch], i + 1);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type, { "**": isolatedBranch }, i + 1);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type, xxTree, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type, xxTree["*"], typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type, listener) {
        type = typeof type === "string" ? type.split(this.delimiter) : type.slice();
        for (var i = 0, len = type.length; i + 1 < len; i++) {
          if (type[i] === "**" && type[i + 1] === "**") {
            return;
          }
        }
        var tree = this.listenerTree;
        var name = type.shift();
        while (name) {
          if (!tree[name]) {
            tree[name] = {};
          }
          tree = tree[name];
          if (type.length === 0) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else if (typeof tree._listeners === "function") {
              tree._listeners = [tree._listeners, listener];
            } else if (isArray(tree._listeners)) {
              tree._listeners.push(listener);
              if (!tree._listeners.warned) {
                var m = defaultMaxListeners;
                if (typeof this._events.maxListeners !== "undefined") {
                  m = this._events.maxListeners;
                }
                if (m > 0 && tree._listeners.length > m) {
                  tree._listeners.warned = true;
                  console.error(
                    "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
                    tree._listeners.length
                  );
                  console.trace();
                }
              }
            }
            return true;
          }
          name = type.shift();
        }
        return true;
      }
      EventEmitter.prototype.delimiter = ".";
      EventEmitter.prototype.setMaxListeners = function(n) {
        this._events || init.call(this);
        this._events.maxListeners = n;
        if (!this._conf) this._conf = {};
        this._conf.maxListeners = n;
      };
      EventEmitter.prototype.event = "";
      EventEmitter.prototype.once = function(event, fn) {
        this.many(event, 1, fn);
        return this;
      };
      EventEmitter.prototype.many = function(event, ttl, fn) {
        var self = this;
        if (typeof fn !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self.off(event, listener);
          }
          fn.apply(this, arguments);
        }
        listener._origin = fn;
        this.on(event, listener);
        return self;
      };
      EventEmitter.prototype.emit = function() {
        this._events || init.call(this);
        var type = arguments[0];
        if (type === "newListener" && !this.newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        if (this._all) {
          var l = arguments.length;
          var args = new Array(l - 1);
          for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
          for (i = 0, l = this._all.length; i < l; i++) {
            this.event = type;
            this._all[i].apply(this, args);
          }
        }
        if (type === "error") {
          if (!this._all && !this._events.error && !(this.wildcard && this.listenerTree.error)) {
            if (arguments[1] instanceof Error) {
              throw arguments[1];
            } else {
              throw new Error("Uncaught, unspecified 'error' event.");
            }
            return false;
          }
        }
        var handler;
        if (this.wildcard) {
          handler = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type];
        }
        if (typeof handler === "function") {
          this.event = type;
          if (arguments.length === 1) {
            handler.call(this);
          } else if (arguments.length > 1)
            switch (arguments.length) {
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                var l = arguments.length;
                var args = new Array(l - 1);
                for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
                handler.apply(this, args);
            }
          return true;
        } else if (handler) {
          var l = arguments.length;
          var args = new Array(l - 1);
          for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
          var listeners = handler.slice();
          for (var i = 0, l = listeners.length; i < l; i++) {
            this.event = type;
            listeners[i].apply(this, args);
          }
          return listeners.length > 0 || !!this._all;
        } else {
          return !!this._all;
        }
      };
      EventEmitter.prototype.on = function(type, listener) {
        if (typeof type === "function") {
          this.onAny(type);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init.call(this);
        this.emit("newListener", type, listener);
        if (this.wildcard) {
          growListenerTree.call(this, type, listener);
          return this;
        }
        if (!this._events[type]) {
          this._events[type] = listener;
        } else if (typeof this._events[type] === "function") {
          this._events[type] = [this._events[type], listener];
        } else if (isArray(this._events[type])) {
          this._events[type].push(listener);
          if (!this._events[type].warned) {
            var m = defaultMaxListeners;
            if (typeof this._events.maxListeners !== "undefined") {
              m = this._events.maxListeners;
            }
            if (m > 0 && this._events[type].length > m) {
              this._events[type].warned = true;
              console.error(
                "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
                this._events[type].length
              );
              console.trace();
            }
          }
        }
        return this;
      };
      EventEmitter.prototype.onAny = function(fn) {
        if (typeof fn !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        this._all.push(fn);
        return this;
      };
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prototype.off = function(type, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
        } else {
          if (!this._events[type]) return this;
          handlers = this._events[type];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray(handlers)) {
            var position = -1;
            for (var i = 0, length = handlers.length; i < length; i++) {
              if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {
                position = i;
                break;
              }
            }
            if (position < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position, 1);
            } else {
              this._events[type].splice(position, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type];
              }
            }
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type];
            }
          }
        }
        return this;
      };
      EventEmitter.prototype.offAny = function(fn) {
        var i = 0, l = 0, fns;
        if (fn && this._all && this._all.length > 0) {
          fns = this._all;
          for (i = 0, l = fns.length; i < l; i++) {
            if (fn === fns[i]) {
              fns.splice(i, 1);
              return this;
            }
          }
        } else {
          this._all = [];
        }
        return this;
      };
      EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
      EventEmitter.prototype.removeAllListeners = function(type) {
        if (arguments.length === 0) {
          !this._events || init.call(this);
          return this;
        }
        if (this.wildcard) {
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
          for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
            var leaf = leafs[iLeaf];
            leaf._listeners = null;
          }
        } else {
          if (!this._events[type]) return this;
          this._events[type] = null;
        }
        return this;
      };
      EventEmitter.prototype.listeners = function(type) {
        if (this.wildcard) {
          var handlers = [];
          var ns = typeof type === "string" ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
          return handlers;
        }
        this._events || init.call(this);
        if (!this._events[type]) this._events[type] = [];
        if (!isArray(this._events[type])) {
          this._events[type] = [this._events[type]];
        }
        return this._events[type];
      };
      EventEmitter.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter;
        });
      } else if (typeof exports === "object") {
        exports.EventEmitter2 = EventEmitter;
      } else {
        window.EventEmitter2 = EventEmitter;
      }
    }();
  }
});

// node_modules/quilljs/lib/lib/dom.js
var require_dom = __commonJS({
  "node_modules/quilljs/lib/lib/dom.js"(exports, module) {
    var SelectWrapper;
    var Wrapper;
    var dom;
    var lastKeyEvent;
    var _;
    var __bind = function(fn, me) {
      return function() {
        return fn.apply(me, arguments);
      };
    };
    var __hasProp = {}.hasOwnProperty;
    var __extends = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    _ = require_lodash();
    lastKeyEvent = null;
    Wrapper = function() {
      function Wrapper2(node) {
        this.node = node;
        this.trigger = __bind(this.trigger, this);
      }
      Wrapper2.prototype.addClass = function(cssClass) {
        if (this.hasClass(cssClass)) {
          return;
        }
        if (this.node.classList != null) {
          this.node.classList.add(cssClass);
        } else if (this.node.className != null) {
          this.node.className = (this.node.className + " " + cssClass).trim();
        }
        return this;
      };
      Wrapper2.prototype.attributes = function(attributes) {
        var attr, i, value, _i, _len, _ref;
        if (attributes) {
          _.each(attributes, /* @__PURE__ */ function(_this) {
            return function(value2, name) {
              return _this.node.setAttribute(name, value2);
            };
          }(this));
          return this;
        } else {
          if (this.node.attributes == null) {
            return {};
          }
          attributes = {};
          _ref = this.node.attributes;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            value = _ref[i];
            attr = this.node.attributes[i];
            attributes[attr.name] = attr.value;
          }
          return attributes;
        }
      };
      Wrapper2.prototype.child = function(offset) {
        var child, length;
        child = this.node.firstChild;
        length = dom(child).length();
        while (child != null) {
          if (offset < length) {
            break;
          }
          offset -= length;
          child = child.nextSibling;
          length = dom(child).length();
        }
        if (child == null) {
          child = this.node.lastChild;
          offset = dom(child).length();
        }
        return [child, offset];
      };
      Wrapper2.prototype.childNodes = function() {
        return _.map(this.node.childNodes);
      };
      Wrapper2.prototype.classes = function() {
        return this.node.className.split(/\s+/);
      };
      Wrapper2.prototype.descendants = function() {
        return _.map(this.node.getElementsByTagName("*"));
      };
      Wrapper2.prototype.get = function() {
        return this.node;
      };
      Wrapper2.prototype.hasClass = function(cssClass) {
        if (this.node.classList != null) {
          return this.node.classList.contains(cssClass);
        } else if (this.node.className != null) {
          return _.indexOf(this.classes(), cssClass) > -1;
        }
        return false;
      };
      Wrapper2.prototype.isAncestor = function(ancestor, inclusive) {
        var node;
        if (inclusive == null) {
          inclusive = false;
        }
        if (ancestor === this.node) {
          return inclusive;
        }
        node = this.node;
        while (node) {
          if (node === ancestor) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      };
      Wrapper2.prototype.isElement = function() {
        var _ref;
        return ((_ref = this.node) != null ? _ref.nodeType : void 0) === dom.ELEMENT_NODE;
      };
      Wrapper2.prototype.isTextNode = function() {
        var _ref;
        return ((_ref = this.node) != null ? _ref.nodeType : void 0) === dom.TEXT_NODE;
      };
      Wrapper2.prototype.length = function() {
        var length;
        if (this.node == null) {
          return 0;
        }
        length = this.text().length;
        if (this.isElement()) {
          length += this.node.querySelectorAll(_.keys(dom.EMBED_TAGS).join(",")).length;
        }
        return length;
      };
      Wrapper2.prototype.merge = function(node) {
        var $node;
        $node = dom(node);
        if (this.isElement()) {
          $node.moveChildren(this.node);
          this.normalize();
        } else {
          this.text(this.text() + $node.text());
        }
        $node.remove();
        return this;
      };
      Wrapper2.prototype.moveChildren = function(newParent) {
        _.each(this.childNodes(), function(child) {
          return newParent.appendChild(child);
        });
        return this;
      };
      Wrapper2.prototype.nextLineNode = function(root) {
        var nextNode;
        nextNode = this.node.nextSibling;
        if (nextNode == null && this.node.parentNode !== root) {
          nextNode = this.node.parentNode.nextSibling;
        }
        if (nextNode != null && dom.LIST_TAGS[nextNode.tagName] != null) {
          nextNode = nextNode.firstChild;
        }
        return nextNode;
      };
      Wrapper2.prototype.normalize = function() {
        var $node, curNode, followingNode, nextNode;
        curNode = this.node.firstChild;
        while (curNode != null) {
          nextNode = curNode.nextSibling;
          $node = dom(curNode);
          if (nextNode != null && dom(nextNode).isTextNode()) {
            if ($node.text().length === 0) {
              $node.remove();
            } else if ($node.isTextNode()) {
              followingNode = nextNode.nextSibling;
              $node.merge(nextNode);
              nextNode = followingNode;
            }
          }
          curNode = nextNode;
        }
        return this;
      };
      Wrapper2.prototype.on = function(eventName, listener) {
        this.node.addEventListener(eventName, /* @__PURE__ */ function(_this) {
          return function(event) {
            var arg, propagate;
            arg = lastKeyEvent && (eventName === "keydown" || eventName === "keyup") ? lastKeyEvent : event;
            propagate = listener.call(_this.node, arg);
            if (!propagate) {
              event.preventDefault();
              event.stopPropagation();
            }
            return propagate;
          };
        }(this));
        return this;
      };
      Wrapper2.prototype.remove = function() {
        var _ref;
        if ((_ref = this.node.parentNode) != null) {
          _ref.removeChild(this.node);
        }
        this.node = null;
        return null;
      };
      Wrapper2.prototype.removeClass = function(cssClass) {
        var classArray;
        if (!this.hasClass(cssClass)) {
          return;
        }
        if (this.node.classList != null) {
          return this.node.classList.remove(cssClass);
        } else if (this.node.className != null) {
          classArray = this.classes();
          classArray.splice(_.indexOf(classArray, cssClass), 1);
          this.node.className = classArray.join(" ");
        }
        return this;
      };
      Wrapper2.prototype.replace = function(newNode) {
        this.node.parentNode.replaceChild(newNode, this.node);
        this.node = newNode;
        return newNode;
      };
      Wrapper2.prototype.splitAncestors = function(root, force) {
        var nextNode, parentClone, parentNode, refNode;
        if (force == null) {
          force = false;
        }
        if (this.node === root || this.node.parentNode === root) {
          return this;
        }
        if (this.node.previousSibling != null || force) {
          parentNode = this.node.parentNode;
          parentClone = parentNode.cloneNode(false);
          parentNode.parentNode.insertBefore(parentClone, parentNode.nextSibling);
          refNode = this.node;
          while (refNode != null) {
            nextNode = refNode.nextSibling;
            parentClone.appendChild(refNode);
            refNode = nextNode;
          }
          return dom(parentClone).splitAncestors(root);
        } else {
          return dom(this.node.parentNode).splitAncestors(root);
        }
      };
      Wrapper2.prototype.split = function(offset, force) {
        var after, child, childLeft, childRight, left, nextRight, nodeLength, right, _ref, _ref1;
        if (force == null) {
          force = false;
        }
        nodeLength = this.length();
        offset = Math.max(0, offset);
        offset = Math.min(offset, nodeLength);
        if (!(force || offset !== 0)) {
          return [this.node.previousSibling, this.node, false];
        }
        if (!(force || offset !== nodeLength)) {
          return [this.node, this.node.nextSibling, false];
        }
        if (this.node.nodeType === dom.TEXT_NODE) {
          after = this.node.splitText(offset);
          return [this.node, after, true];
        } else {
          left = this.node;
          right = this.node.cloneNode(false);
          this.node.parentNode.insertBefore(right, left.nextSibling);
          _ref = this.child(offset), child = _ref[0], offset = _ref[1];
          _ref1 = dom(child).split(offset), childLeft = _ref1[0], childRight = _ref1[1];
          while (childRight !== null) {
            nextRight = childRight.nextSibling;
            right.appendChild(childRight);
            childRight = nextRight;
          }
          return [left, right, true];
        }
      };
      Wrapper2.prototype.styles = function(styles, overwrite) {
        var obj, styleString;
        if (overwrite == null) {
          overwrite = false;
        }
        if (styles) {
          if (!overwrite) {
            styles = _.defaults(styles, this.styles());
          }
          styleString = _.map(styles, function(style, name) {
            return "" + name + ": " + style;
          }).join("; ") + ";";
          this.node.setAttribute("style", styleString);
          return this;
        } else {
          styleString = this.node.getAttribute("style") || "";
          obj = _.reduce(styleString.split(";"), function(styles2, str) {
            var name, value, _ref;
            _ref = str.split(":"), name = _ref[0], value = _ref[1];
            if (name && value) {
              name = name.trim();
              value = value.trim();
              styles2[name.toLowerCase()] = value;
            }
            return styles2;
          }, {});
          return obj;
        }
      };
      Wrapper2.prototype.switchTag = function(newTag) {
        var attributes, newNode;
        newTag = newTag.toUpperCase();
        if (this.node.tagName === newTag) {
          return this;
        }
        newNode = this.node.ownerDocument.createElement(newTag);
        attributes = this.attributes();
        if (dom.VOID_TAGS[newTag] == null) {
          this.moveChildren(newNode);
        }
        this.replace(newNode);
        return this.attributes(attributes).get();
      };
      Wrapper2.prototype.text = function(text) {
        if (text != null) {
          switch (this.node.nodeType) {
            case dom.ELEMENT_NODE:
              this.node.textContent = text;
              break;
            case dom.TEXT_NODE:
              this.node.data = text;
          }
          return this;
        } else {
          switch (this.node.nodeType) {
            case dom.ELEMENT_NODE:
              if (this.node.tagName === dom.DEFAULT_BREAK_TAG) {
                return "";
              }
              if (dom.EMBED_TAGS[this.node.tagName] != null) {
                return dom.EMBED_TEXT;
              }
              if (this.node.textContent != null) {
                return this.node.textContent;
              }
              return "";
            case dom.TEXT_NODE:
              return this.node.data || "";
            default:
              return "";
          }
        }
      };
      Wrapper2.prototype.textNodes = function() {
        var textNode, textNodes, walker;
        walker = this.node.ownerDocument.createTreeWalker(this.node, NodeFilter.SHOW_TEXT, null, false);
        textNodes = [];
        while (textNode = walker.nextNode()) {
          textNodes.push(textNode);
        }
        return textNodes;
      };
      Wrapper2.prototype.toggleClass = function(className, state) {
        if (state == null) {
          state = !this.hasClass(className);
        }
        if (state) {
          this.addClass(className);
        } else {
          this.removeClass(className);
        }
        return this;
      };
      Wrapper2.prototype.trigger = function(eventName, options) {
        var event, initFn, modifiers;
        if (options == null) {
          options = {};
        }
        if (_.indexOf(["keypress", "keydown", "keyup"], eventName) < 0) {
          event = this.node.ownerDocument.createEvent("Event");
          event.initEvent(eventName, options.bubbles, options.cancelable);
        } else {
          event = this.node.ownerDocument.createEvent("KeyboardEvent");
          lastKeyEvent = _.clone(options);
          if (_.isNumber(options.key)) {
            lastKeyEvent.which = options.key;
          } else if (_.isString(options.key)) {
            lastKeyEvent.which = options.key.toUpperCase().charCodeAt(0);
          } else {
            lastKeyEvent.which = 0;
          }
          if (dom.isIE(10)) {
            modifiers = [];
            if (options.altKey) {
              modifiers.push("Alt");
            }
            if (options.ctrlKey) {
              modifiers.push("Control");
            }
            if (options.metaKey) {
              modifiers.push("Meta");
            }
            if (options.shiftKey) {
              modifiers.push("Shift");
            }
            event.initKeyboardEvent(eventName, options.bubbles, options.cancelable, this.window(), 0, 0, modifiers.join(" "), null, null);
          } else {
            initFn = _.isFunction(event.initKeyboardEvent) ? "initKeyboardEvent" : "initKeyEvent";
            event[initFn](eventName, options.bubbles, options.cancelable, this.window(), options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, 0, 0);
          }
        }
        this.node.dispatchEvent(event);
        lastKeyEvent = null;
        return this;
      };
      Wrapper2.prototype.unwrap = function() {
        var next, ret;
        ret = this.node.firstChild;
        next = this.node.nextSibling;
        _.each(this.childNodes(), /* @__PURE__ */ function(_this) {
          return function(child) {
            return _this.node.parentNode.insertBefore(child, next);
          };
        }(this));
        this.remove();
        return ret;
      };
      Wrapper2.prototype.window = function() {
        return this.node.ownerDocument.defaultView || this.node.ownerDocument.parentWindow;
      };
      Wrapper2.prototype.wrap = function(wrapper) {
        var parent;
        if (this.node.parentNode != null) {
          this.node.parentNode.insertBefore(wrapper, this.node);
        }
        parent = wrapper;
        while (parent.firstChild != null) {
          parent = wrapper.firstChild;
        }
        parent.appendChild(this.node);
        return this;
      };
      return Wrapper2;
    }();
    SelectWrapper = function(_super) {
      __extends(SelectWrapper2, _super);
      function SelectWrapper2() {
        return SelectWrapper2.__super__.constructor.apply(this, arguments);
      }
      SelectWrapper2.prototype["default"] = function() {
        return this.node.querySelector("option[selected]");
      };
      SelectWrapper2.prototype.option = function(option, trigger) {
        var child, i, value, _i, _len, _ref;
        if (trigger == null) {
          trigger = true;
        }
        value = _.isElement(option) ? option.value : option;
        if (value) {
          value = value.replace(/[^\w]+/g, "");
          _ref = this.node.children;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            child = _ref[i];
            if (child.value.replace(/[^\w]+/g, "") === value) {
              this.node.selectedIndex = i;
              break;
            }
          }
        } else {
          this.node.selectedIndex = -1;
        }
        if (trigger) {
          this.trigger("change");
        }
        return this;
      };
      SelectWrapper2.prototype.reset = function(trigger) {
        var option;
        if (trigger == null) {
          trigger = true;
        }
        option = this["default"]();
        if (option != null) {
          option.selected = true;
        } else {
          this.node.selectedIndex = 0;
        }
        if (trigger) {
          this.trigger("change");
        }
        return this;
      };
      SelectWrapper2.prototype.value = function() {
        if (this.node.selectedIndex > -1) {
          return this.node.options[this.node.selectedIndex].value;
        } else {
          return "";
        }
      };
      return SelectWrapper2;
    }(Wrapper);
    dom = function(node) {
      if ((node != null ? node.tagName : void 0) === "SELECT") {
        return new SelectWrapper(node);
      } else {
        return new Wrapper(node);
      }
    };
    dom = _.extend(dom, {
      ELEMENT_NODE: 1,
      NOBREAK_SPACE: "&nbsp;",
      TEXT_NODE: 3,
      ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF",
      DEFAULT_BLOCK_TAG: "DIV",
      DEFAULT_BREAK_TAG: "BR",
      DEFAULT_INLINE_TAG: "SPAN",
      EMBED_TEXT: "!",
      FONT_SIZES: {
        "10px": 1,
        "13px": 2,
        "16px": 3,
        "18px": 4,
        "24px": 5,
        "32px": 6,
        "48px": 7
      },
      KEYS: {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        ESCAPE: 27,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        DELETE: 46
      },
      BLOCK_TAGS: {
        "ADDRESS": "ADDRESS",
        "ARTICLE": "ARTICLE",
        "ASIDE": "ASIDE",
        "AUDIO": "AUDIO",
        "BLOCKQUOTE": "BLOCKQUOTE",
        "CANVAS": "CANVAS",
        "DD": "DD",
        "DIV": "DIV",
        "DL": "DL",
        "FIGCAPTION": "FIGCAPTION",
        "FIGURE": "FIGURE",
        "FOOTER": "FOOTER",
        "FORM": "FORM",
        "H1": "H1",
        "H2": "H2",
        "H3": "H3",
        "H4": "H4",
        "H5": "H5",
        "H6": "H6",
        "HEADER": "HEADER",
        "HGROUP": "HGROUP",
        "LI": "LI",
        "OL": "OL",
        "OUTPUT": "OUTPUT",
        "P": "P",
        "PRE": "PRE",
        "SECTION": "SECTION",
        "TABLE": "TABLE",
        "TBODY": "TBODY",
        "TD": "TD",
        "TFOOT": "TFOOT",
        "TH": "TH",
        "THEAD": "THEAD",
        "TR": "TR",
        "UL": "UL",
        "VIDEO": "VIDEO"
      },
      EMBED_TAGS: {
        "IMG": "IMG"
      },
      LINE_TAGS: {
        "DIV": "DIV",
        "LI": "LI"
      },
      LIST_TAGS: {
        "OL": "OL",
        "UL": "UL"
      },
      VOID_TAGS: {
        "AREA": "AREA",
        "BASE": "BASE",
        "BR": "BR",
        "COL": "COL",
        "COMMAND": "COMMAND",
        "EMBED": "EMBED",
        "HR": "HR",
        "IMG": "IMG",
        "INPUT": "INPUT",
        "KEYGEN": "KEYGEN",
        "LINK": "LINK",
        "META": "META",
        "PARAM": "PARAM",
        "SOURCE": "SOURCE",
        "TRACK": "TRACK",
        "WBR": "WBR"
      },
      convertFontSize: function(size) {
        var i, s, sources, targets;
        if (_.isString(size) && size.indexOf("px") > -1) {
          sources = _.keys(dom.FONT_SIZES);
          targets = _.values(dom.FONT_SIZES);
        } else {
          targets = _.keys(dom.FONT_SIZES);
          sources = _.values(dom.FONT_SIZES);
        }
        for (i in sources) {
          s = sources[i];
          if (parseInt(size) <= parseInt(s)) {
            return targets[i];
          }
        }
        return _.last(targets);
      },
      isIE: function(maxVersion) {
        var version;
        version = document.documentMode;
        return version && maxVersion >= version;
      },
      isIOS: function() {
        return /iPhone|iPad/i.test(navigator.userAgent);
      },
      isMac: function() {
        return /Mac/i.test(navigator.platform);
      }
    });
    module.exports = dom;
  }
});

// node_modules/quilljs/lib/core/format.js
var require_format = __commonJS({
  "node_modules/quilljs/lib/core/format.js"(exports, module) {
    var Format;
    var dom;
    var _;
    _ = require_lodash();
    dom = require_dom();
    Format = function() {
      Format2.types = {
        LINE: "line"
      };
      Format2.FORMATS = {
        bold: {
          tag: "B",
          prepare: "bold"
        },
        italic: {
          tag: "I",
          prepare: "italic"
        },
        underline: {
          tag: "U",
          prepare: "underline"
        },
        strike: {
          tag: "S",
          prepare: "strikeThrough"
        },
        color: {
          style: "color",
          "default": "rgb(0, 0, 0)",
          prepare: "foreColor"
        },
        background: {
          style: "backgroundColor",
          "default": "rgb(255, 255, 255)",
          prepare: "backColor"
        },
        font: {
          style: "fontFamily",
          "default": "'Helvetica', 'Arial', sans-serif",
          prepare: "fontName"
        },
        size: {
          style: "fontSize",
          "default": "13px",
          prepare: function(doc, value) {
            return doc.execCommand("fontSize", false, dom.convertFontSize(value));
          }
        },
        link: {
          tag: "A",
          attribute: "href"
        },
        image: {
          tag: "IMG",
          attribute: "src"
        },
        align: {
          type: Format2.types.LINE,
          style: "textAlign",
          "default": "left"
        },
        bullet: {
          type: Format2.types.LINE,
          exclude: "list",
          parentTag: "UL",
          tag: "LI"
        },
        list: {
          type: Format2.types.LINE,
          exclude: "bullet",
          parentTag: "OL",
          tag: "LI"
        }
      };
      function Format2(document2, config) {
        this.document = document2;
        this.config = config;
      }
      Format2.prototype.add = function(node, value) {
        var formatNode, inline, parentNode, _ref, _ref1;
        if (!value) {
          return this.remove(node);
        }
        if (this.value(node) === value) {
          return node;
        }
        if (_.isString(this.config.parentTag)) {
          parentNode = this.document.createElement(this.config.parentTag);
          dom(node).wrap(parentNode);
          if (node.parentNode.tagName === ((_ref = node.parentNode.previousSibling) != null ? _ref.tagName : void 0)) {
            dom(node.parentNode.previousSibling).merge(node.parentNode);
          }
          if (node.parentNode.tagName === ((_ref1 = node.parentNode.nextSibling) != null ? _ref1.tagName : void 0)) {
            dom(node.parentNode).merge(node.parentNode.nextSibling);
          }
        }
        if (_.isString(this.config.tag)) {
          formatNode = this.document.createElement(this.config.tag);
          if (dom.VOID_TAGS[formatNode.tagName] != null) {
            if (node.parentNode != null) {
              dom(node).replace(formatNode);
            }
            node = formatNode;
          } else if (this.isType(Format2.types.LINE)) {
            node = dom(node).switchTag(this.config.tag);
          } else {
            dom(node).wrap(formatNode);
            node = formatNode;
          }
        }
        if (_.isString(this.config.style) || _.isString(this.config.attribute) || _.isString(this.config["class"])) {
          if (_.isString(this.config["class"])) {
            node = this.remove(node);
          }
          if (dom(node).isTextNode()) {
            inline = this.document.createElement(dom.DEFAULT_INLINE_TAG);
            dom(node).wrap(inline);
            node = inline;
          }
          if (_.isString(this.config.style)) {
            if (value !== this.config["default"]) {
              node.style[this.config.style] = value;
            }
          }
          if (_.isString(this.config.attribute)) {
            node.setAttribute(this.config.attribute, value);
          }
          if (_.isString(this.config["class"])) {
            dom(node).addClass(this.config["class"] + value);
          }
        }
        return node;
      };
      Format2.prototype.isType = function(type) {
        return type === this.config.type;
      };
      Format2.prototype.match = function(node) {
        var c, _i, _len, _ref, _ref1;
        if (!dom(node).isElement()) {
          return false;
        }
        if (_.isString(this.config.parentTag) && ((_ref = node.parentNode) != null ? _ref.tagName : void 0) !== this.config.parentTag) {
          return false;
        }
        if (_.isString(this.config.tag) && node.tagName !== this.config.tag) {
          return false;
        }
        if (_.isString(this.config.style) && (!node.style[this.config.style] || node.style[this.config.style] === this.config["default"])) {
          return false;
        }
        if (_.isString(this.config.attribute) && !node.hasAttribute(this.config.attribute)) {
          return false;
        }
        if (_.isString(this.config["class"])) {
          _ref1 = dom(node).classes();
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            c = _ref1[_i];
            if (c.indexOf(this.config["class"]) === 0) {
              return true;
            }
          }
          return false;
        }
        return true;
      };
      Format2.prototype.prepare = function(value) {
        if (_.isString(this.config.prepare)) {
          return this.document.execCommand(this.config.prepare, false, value);
        } else if (_.isFunction(this.config.prepare)) {
          return this.config.prepare(this.document, value);
        }
      };
      Format2.prototype.remove = function(node) {
        var c, _i, _len, _ref;
        if (!this.match(node)) {
          return node;
        }
        if (_.isString(this.config.style)) {
          node.style[this.config.style] = "";
          if (!node.getAttribute("style")) {
            node.removeAttribute("style");
          }
        }
        if (_.isString(this.config.attribute)) {
          node.removeAttribute(this.config.attribute);
        }
        if (_.isString(this.config["class"])) {
          _ref = dom(node).classes();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            if (c.indexOf(this.config["class"]) === 0) {
              dom(node).removeClass(c);
            }
          }
          if (!node.getAttribute("class")) {
            node.removeAttribute("class");
          }
        }
        if (_.isString(this.config.tag)) {
          if (this.isType(Format2.types.LINE)) {
            if (_.isString(this.config.parentTag)) {
              if (node.previousSibling != null) {
                dom(node).splitAncestors(node.parentNode.parentNode);
              }
              if (node.nextSibling != null) {
                dom(node.nextSibling).splitAncestors(node.parentNode.parentNode);
              }
            }
            node = dom(node).switchTag(dom.DEFAULT_BLOCK_TAG);
          } else {
            node = dom(node).switchTag(dom.DEFAULT_INLINE_TAG);
            if (dom.EMBED_TAGS[this.config.tag] != null) {
              dom(node).text(dom.EMBED_TEXT);
            }
          }
        }
        if (_.isString(this.config.parentTag)) {
          dom(node.parentNode).unwrap();
        }
        if (node.tagName === dom.DEFAULT_INLINE_TAG && !node.hasAttributes()) {
          node = dom(node).unwrap();
        }
        return node;
      };
      Format2.prototype.value = function(node) {
        var c, _i, _len, _ref;
        if (!this.match(node)) {
          return void 0;
        }
        if (_.isString(this.config.attribute)) {
          return node.getAttribute(this.config.attribute) || void 0;
        } else if (_.isString(this.config.style)) {
          return node.style[this.config.style] || void 0;
        } else if (_.isString(this.config["class"])) {
          _ref = dom(node).classes();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            if (c.indexOf(this.config["class"]) === 0) {
              return c.slice(this.config["class"].length);
            }
          }
        } else if (_.isString(this.config.tag)) {
          return true;
        }
        return void 0;
      };
      return Format2;
    }();
    module.exports = Format;
  }
});

// node_modules/quilljs/lib/lib/linked-list.js
var require_linked_list = __commonJS({
  "node_modules/quilljs/lib/lib/linked-list.js"(exports, module) {
    var LinkedList;
    var Node;
    Node = /* @__PURE__ */ function() {
      function Node2(data) {
        this.data = data;
        this.prev = this.next = null;
      }
      return Node2;
    }();
    LinkedList = function() {
      LinkedList2.Node = Node;
      function LinkedList2() {
        this.length = 0;
        this.first = this.last = null;
      }
      LinkedList2.prototype.append = function(node) {
        if (this.first != null) {
          node.next = null;
          this.last.next = node;
        } else {
          this.first = node;
        }
        node.prev = this.last;
        this.last = node;
        return this.length += 1;
      };
      LinkedList2.prototype.insertAfter = function(refNode, newNode) {
        newNode.prev = refNode;
        if (refNode != null) {
          newNode.next = refNode.next;
          if (refNode.next != null) {
            refNode.next.prev = newNode;
          }
          refNode.next = newNode;
          if (refNode === this.last) {
            this.last = newNode;
          }
        } else {
          newNode.next = this.first;
          this.first.prev = newNode;
          this.first = newNode;
        }
        return this.length += 1;
      };
      LinkedList2.prototype.remove = function(node) {
        if (this.length > 1) {
          if (node.prev != null) {
            node.prev.next = node.next;
          }
          if (node.next != null) {
            node.next.prev = node.prev;
          }
          if (node === this.first) {
            this.first = node.next;
          }
          if (node === this.last) {
            this.last = node.prev;
          }
        } else {
          this.first = this.last = null;
        }
        node.prev = node.next = null;
        return this.length -= 1;
      };
      LinkedList2.prototype.toArray = function() {
        var arr, cur;
        arr = [];
        cur = this.first;
        while (cur != null) {
          arr.push(cur);
          cur = cur.next;
        }
        return arr;
      };
      return LinkedList2;
    }();
    module.exports = LinkedList;
  }
});

// node_modules/quilljs/lib/core/leaf.js
var require_leaf = __commonJS({
  "node_modules/quilljs/lib/core/leaf.js"(exports, module) {
    var Format;
    var Leaf;
    var LinkedList;
    var dom;
    var _;
    var __hasProp = {}.hasOwnProperty;
    var __extends = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    _ = require_lodash();
    dom = require_dom();
    Format = require_format();
    LinkedList = require_linked_list();
    Leaf = function(_super) {
      __extends(Leaf2, _super);
      Leaf2.ID_PREFIX = "leaf-";
      Leaf2.isLeafNode = function(node) {
        return dom(node).isTextNode() || node.firstChild == null;
      };
      function Leaf2(node, formats) {
        this.node = node;
        this.formats = _.clone(formats);
        this.id = _.uniqueId(Leaf2.ID_PREFIX);
        this.text = dom(this.node).text();
        this.length = this.text.length;
      }
      Leaf2.prototype.deleteText = function(offset, length) {
        var textNode;
        if (!(length > 0)) {
          return;
        }
        this.text = this.text.slice(0, offset) + this.text.slice(offset + length);
        this.length = this.text.length;
        if (dom.EMBED_TAGS[this.node.tagName] != null) {
          textNode = this.node.ownerDocument.createTextNode(this.text);
          return this.node = dom(this.node).replace(textNode);
        } else {
          return dom(this.node).text(this.text);
        }
      };
      Leaf2.prototype.insertText = function(offset, text) {
        var textNode;
        this.text = this.text.slice(0, offset) + text + this.text.slice(offset);
        if (dom(this.node).isTextNode()) {
          dom(this.node).text(this.text);
        } else {
          textNode = this.node.ownerDocument.createTextNode(text);
          if (this.node.tagName === dom.DEFAULT_BREAK_TAG) {
            this.node = dom(this.node).replace(textNode);
          } else {
            this.node.appendChild(textNode);
            this.node = textNode;
          }
        }
        return this.length = this.text.length;
      };
      return Leaf2;
    }(LinkedList.Node);
    module.exports = Leaf;
  }
});

// node_modules/quilljs/lib/lib/normalizer.js
var require_normalizer = __commonJS({
  "node_modules/quilljs/lib/lib/normalizer.js"(exports, module) {
    var Normalizer;
    var dom;
    var _;
    _ = require_lodash();
    dom = require_dom();
    Normalizer = {
      ALIASES: {
        "STRONG": "B",
        "EM": "I",
        "DEL": "S",
        "STRIKE": "S"
      },
      ATTRIBUTES: {
        "color": "color",
        "face": "fontFamily",
        "size": "fontSize"
      },
      STYLES: {
        "background-color": "background-color",
        "color": "color",
        "font-family": "font-family",
        "font-size": "font-size",
        "text-align": "text-align"
      },
      TAGS: {
        "DIV": "DIV",
        "BR": "BR",
        "SPAN": "SPAN",
        "B": "B",
        "I": "I",
        "S": "S",
        "U": "U",
        "A": "A",
        "IMG": "IMG",
        "OL": "OL",
        "UL": "UL",
        "LI": "LI"
      },
      handleBreaks: function(lineNode) {
        var breaks;
        breaks = _.map(lineNode.querySelectorAll(dom.DEFAULT_BREAK_TAG));
        _.each(breaks, /* @__PURE__ */ function(_this) {
          return function(br) {
            if (br.nextSibling != null && (!dom.isIE(10) || br.previousSibling != null)) {
              return dom(br.nextSibling).splitAncestors(lineNode.parentNode);
            }
          };
        }(this));
        return lineNode;
      },
      normalizeLine: function(lineNode) {
        lineNode = Normalizer.wrapInline(lineNode);
        lineNode = Normalizer.handleBreaks(lineNode);
        lineNode = Normalizer.pullBlocks(lineNode);
        lineNode = Normalizer.normalizeNode(lineNode);
        Normalizer.unwrapText(lineNode);
        if (lineNode != null && dom.LIST_TAGS[lineNode.tagName] != null) {
          lineNode = lineNode.firstChild;
        }
        return lineNode;
      },
      normalizeNode: function(node) {
        if (dom(node).isTextNode()) {
          return node;
        }
        _.each(Normalizer.ATTRIBUTES, function(style, attribute) {
          var value;
          if (node.hasAttribute(attribute)) {
            value = node.getAttribute(attribute);
            if (attribute === "size") {
              value = dom.convertFontSize(value);
            }
            node.style[style] = value;
            return node.removeAttribute(attribute);
          }
        });
        Normalizer.whitelistStyles(node);
        return Normalizer.whitelistTags(node);
      },
      optimizeLine: function(lineNode) {
        var lineNodeLength, node, nodes, _results;
        lineNodeLength = dom(lineNode).length();
        nodes = dom(lineNode).descendants();
        _results = [];
        while (nodes.length > 0) {
          node = nodes.pop();
          if ((node != null ? node.parentNode : void 0) == null) {
            continue;
          }
          if (dom.EMBED_TAGS[node.tagName] != null) {
            continue;
          }
          if (node.tagName === dom.DEFAULT_BREAK_TAG) {
            if (lineNodeLength !== 0) {
              _results.push(dom(node).remove());
            } else {
              _results.push(void 0);
            }
          } else if (dom(node).length() === 0) {
            nodes.push(node.nextSibling);
            _results.push(dom(node).unwrap());
          } else if (node.previousSibling != null && node.tagName === node.previousSibling.tagName) {
            if (_.isEqual(dom(node).attributes(), dom(node.previousSibling).attributes())) {
              nodes.push(node.firstChild);
              _results.push(dom(node.previousSibling).merge(node));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      pullBlocks: function(lineNode) {
        var curNode;
        curNode = lineNode.firstChild;
        while (curNode != null) {
          if (dom.BLOCK_TAGS[curNode.tagName] != null && curNode.tagName !== "LI") {
            if (curNode.previousSibling != null) {
              dom(curNode).splitAncestors(lineNode.parentNode);
            }
            if (curNode.nextSibling != null) {
              dom(curNode.nextSibling).splitAncestors(lineNode.parentNode);
            }
            if (dom.LIST_TAGS[curNode.tagName] == null || !curNode.firstChild) {
              dom(curNode).unwrap();
              Normalizer.pullBlocks(lineNode);
            } else {
              dom(curNode.parentNode).unwrap();
              if (lineNode.parentNode == null) {
                lineNode = curNode;
              }
            }
            break;
          }
          curNode = curNode.nextSibling;
        }
        return lineNode;
      },
      stripComments: function(html) {
        return html.replace(/<!--[\s\S]*?-->/g, "");
      },
      stripWhitespace: function(html) {
        html = html.replace(/^\s+/, "").replace(/\s+$/, "");
        html = html.replace(/^\s+/, "").replace(/\s+$/, "");
        html = html.replace(/(\r?\n|\r)+/g, " ");
        html = html.replace(/\>\s+\</g, "><");
        return html;
      },
      whitelistStyles: function(node) {
        var original, styles;
        original = dom(node).styles();
        styles = _.omit(original, function(value, key) {
          return Normalizer.STYLES[key] == null;
        });
        if (_.keys(styles).length < _.keys(original).length) {
          if (_.keys(styles).length > 0) {
            return dom(node).styles(styles, true);
          } else {
            return node.removeAttribute("style");
          }
        }
      },
      whitelistTags: function(node) {
        if (!dom(node).isElement()) {
          return node;
        }
        if (Normalizer.ALIASES[node.tagName] != null) {
          node = dom(node).switchTag(Normalizer.ALIASES[node.tagName]);
        } else if (Normalizer.TAGS[node.tagName] == null) {
          if (dom.BLOCK_TAGS[node.tagName] != null) {
            node = dom(node).switchTag(dom.DEFAULT_BLOCK_TAG);
          } else if (!node.hasAttributes() && node.firstChild != null) {
            node = dom(node).unwrap();
          } else {
            node = dom(node).switchTag(dom.DEFAULT_INLINE_TAG);
          }
        }
        return node;
      },
      wrapInline: function(lineNode) {
        var blockNode, nextNode;
        if (dom.BLOCK_TAGS[lineNode.tagName] != null) {
          return lineNode;
        }
        blockNode = lineNode.ownerDocument.createElement(dom.DEFAULT_BLOCK_TAG);
        lineNode.parentNode.insertBefore(blockNode, lineNode);
        while (lineNode != null && dom.BLOCK_TAGS[lineNode.tagName] == null) {
          nextNode = lineNode.nextSibling;
          blockNode.appendChild(lineNode);
          lineNode = nextNode;
        }
        return blockNode;
      },
      unwrapText: function(lineNode) {
        var spans;
        spans = _.map(lineNode.querySelectorAll(dom.DEFAULT_INLINE_TAG));
        return _.each(spans, function(span) {
          if (!span.hasAttributes()) {
            return dom(span).unwrap();
          }
        });
      }
    };
    module.exports = Normalizer;
  }
});

// node_modules/quilljs/lib/core/line.js
var require_line = __commonJS({
  "node_modules/quilljs/lib/core/line.js"(exports, module) {
    var Delta;
    var Format;
    var Leaf;
    var Line;
    var LinkedList;
    var Normalizer;
    var dom;
    var _;
    var __hasProp = {}.hasOwnProperty;
    var __extends = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    _ = require_lodash();
    Delta = require_rich_text().Delta;
    dom = require_dom();
    Format = require_format();
    Leaf = require_leaf();
    Line = require_line();
    LinkedList = require_linked_list();
    Normalizer = require_normalizer();
    Line = function(_super) {
      __extends(Line2, _super);
      Line2.CLASS_NAME = "line";
      Line2.ID_PREFIX = "line-";
      function Line2(doc, node) {
        this.doc = doc;
        this.node = node;
        this.id = _.uniqueId(Line2.ID_PREFIX);
        this.formats = {};
        dom(this.node).addClass(Line2.CLASS_NAME);
        this.rebuild();
        Line2.__super__.constructor.call(this, this.node);
      }
      Line2.prototype.buildLeaves = function(node, formats) {
        return _.each(dom(node).childNodes(), /* @__PURE__ */ function(_this) {
          return function(node2) {
            var nodeFormats;
            node2 = Normalizer.normalizeNode(node2);
            nodeFormats = _.clone(formats);
            _.each(_this.doc.formats, function(format, name) {
              if (!format.isType(Format.types.LINE) && format.match(node2)) {
                return nodeFormats[name] = format.value(node2);
              }
            });
            if (Leaf.isLeafNode(node2)) {
              return _this.leaves.append(new Leaf(node2, nodeFormats));
            } else {
              return _this.buildLeaves(node2, nodeFormats);
            }
          };
        }(this));
      };
      Line2.prototype.deleteText = function(offset, length) {
        var deleteLength, leaf, _ref;
        if (!(length > 0)) {
          return;
        }
        _ref = this.findLeafAt(offset), leaf = _ref[0], offset = _ref[1];
        while (leaf != null && length > 0) {
          deleteLength = Math.min(length, leaf.length - offset);
          leaf.deleteText(offset, deleteLength);
          length -= deleteLength;
          leaf = leaf.next;
          offset = 0;
        }
        return this.rebuild();
      };
      Line2.prototype.findLeaf = function(leafNode) {
        var curLeaf;
        curLeaf = this.leaves.first;
        while (curLeaf != null) {
          if (curLeaf.node === leafNode) {
            return curLeaf;
          }
          curLeaf = curLeaf.next;
        }
        return null;
      };
      Line2.prototype.findLeafAt = function(offset, inclusive) {
        var leaf;
        if (inclusive == null) {
          inclusive = false;
        }
        if (offset >= this.length - 1) {
          return [this.leaves.last, this.leaves.last.length];
        }
        leaf = this.leaves.first;
        while (leaf != null) {
          if (offset < leaf.length || offset === leaf.length && inclusive) {
            return [leaf, offset];
          }
          offset -= leaf.length;
          leaf = leaf.next;
        }
        return [this.leaves.last, offset - this.leaves.last.length];
      };
      Line2.prototype.format = function(name, value) {
        var formats;
        if (_.isObject(name)) {
          formats = name;
        } else {
          formats = {};
          formats[name] = value;
        }
        _.each(formats, /* @__PURE__ */ function(_this) {
          return function(value2, name2) {
            var excludeFormat, format;
            format = _this.doc.formats[name2];
            if (format.isType(Format.types.LINE)) {
              if (format.config.exclude && _this.formats[format.config.exclude]) {
                excludeFormat = _this.doc.formats[format.config.exclude];
                if (excludeFormat != null) {
                  _this.node = excludeFormat.remove(_this.node);
                  delete _this.formats[format.config.exclude];
                }
              }
              _this.node = format.add(_this.node, value2);
            }
            if (value2) {
              return _this.formats[name2] = value2;
            } else {
              return delete _this.formats[name2];
            }
          };
        }(this));
        return this.resetContent();
      };
      Line2.prototype.formatText = function(offset, length, name, value) {
        var format, leaf, leafOffset, leftNode, nextLeaf, rightNode, targetNode, _ref, _ref1, _ref2;
        _ref = this.findLeafAt(offset), leaf = _ref[0], leafOffset = _ref[1];
        format = this.doc.formats[name];
        if (!(format != null && format.config.type !== Format.types.LINE)) {
          return;
        }
        while (leaf != null && length > 0) {
          nextLeaf = leaf.next;
          if (value && leaf.formats[name] !== value || !value && leaf.formats[name] != null) {
            targetNode = leaf.node;
            if (leaf.formats[name] != null) {
              dom(targetNode).splitAncestors(this.node);
              while (!format.match(targetNode)) {
                targetNode = targetNode.parentNode;
              }
            }
            if (leafOffset > 0) {
              _ref1 = dom(targetNode).split(leafOffset), leftNode = _ref1[0], targetNode = _ref1[1];
            }
            if (leaf.length > leafOffset + length) {
              _ref2 = dom(targetNode).split(length), targetNode = _ref2[0], rightNode = _ref2[1];
            }
            format.add(targetNode, value);
          }
          length -= leaf.length - leafOffset;
          leafOffset = 0;
          leaf = nextLeaf;
        }
        return this.rebuild();
      };
      Line2.prototype.insertText = function(offset, text, formats) {
        var leaf, leafOffset, nextNode, node, prevNode, _ref, _ref1;
        if (formats == null) {
          formats = {};
        }
        if (!(text.length > 0)) {
          return;
        }
        _ref = this.findLeafAt(offset), leaf = _ref[0], leafOffset = _ref[1];
        if (_.isEqual(leaf.formats, formats)) {
          leaf.insertText(leafOffset, text);
          return this.resetContent();
        } else {
          node = _.reduce(formats, /* @__PURE__ */ function(_this) {
            return function(node2, value, name) {
              return _this.doc.formats[name].add(node2, value);
            };
          }(this), this.node.ownerDocument.createTextNode(text));
          _ref1 = dom(leaf.node).split(leafOffset), prevNode = _ref1[0], nextNode = _ref1[1];
          if (nextNode) {
            nextNode = dom(nextNode).splitAncestors(this.node).get();
          }
          this.node.insertBefore(node, nextNode);
          return this.rebuild();
        }
      };
      Line2.prototype.optimize = function() {
        Normalizer.optimizeLine(this.node);
        return this.rebuild();
      };
      Line2.prototype.rebuild = function(force) {
        if (force == null) {
          force = false;
        }
        if (!force && this.outerHTML != null && this.outerHTML === this.node.outerHTML) {
          if (_.all(this.leaves.toArray(), /* @__PURE__ */ function(_this) {
            return function(leaf) {
              return dom(leaf.node).isAncestor(_this.node);
            };
          }(this))) {
            return false;
          }
        }
        this.node = Normalizer.normalizeNode(this.node);
        if (dom(this.node).length() === 0 && !this.node.querySelector(dom.DEFAULT_BREAK_TAG)) {
          this.node.appendChild(this.node.ownerDocument.createElement(dom.DEFAULT_BREAK_TAG));
        }
        this.leaves = new LinkedList();
        this.formats = _.reduce(this.doc.formats, /* @__PURE__ */ function(_this) {
          return function(formats, format, name) {
            if (format.isType(Format.types.LINE)) {
              if (format.match(_this.node)) {
                formats[name] = format.value(_this.node);
              } else {
                delete formats[name];
              }
            }
            return formats;
          };
        }(this), this.formats);
        this.buildLeaves(this.node, {});
        this.resetContent();
        return true;
      };
      Line2.prototype.resetContent = function() {
        if (this.node.id !== this.id) {
          this.node.id = this.id;
        }
        this.outerHTML = this.node.outerHTML;
        this.length = 1;
        this.delta = new Delta();
        this.leaves.toArray().forEach(/* @__PURE__ */ function(_this) {
          return function(leaf) {
            _this.length += leaf.length;
            if (dom.EMBED_TAGS[leaf.node.tagName] != null) {
              return _this.delta.insert(1, leaf.formats);
            } else {
              return _this.delta.insert(leaf.text, leaf.formats);
            }
          };
        }(this));
        return this.delta.insert("\n", this.formats);
      };
      return Line2;
    }(LinkedList.Node);
    module.exports = Line;
  }
});

// node_modules/quilljs/lib/core/document.js
var require_document = __commonJS({
  "node_modules/quilljs/lib/core/document.js"(exports, module) {
    var Delta;
    var Document;
    var Format;
    var Line;
    var LinkedList;
    var Normalizer;
    var dom;
    var _;
    _ = require_lodash();
    Delta = require_rich_text().Delta;
    dom = require_dom();
    Format = require_format();
    Line = require_line();
    LinkedList = require_linked_list();
    Normalizer = require_normalizer();
    Document = function() {
      function Document2(root, options) {
        this.root = root;
        if (options == null) {
          options = {};
        }
        this.formats = {};
        _.each(options.formats, _.bind(this.addFormat, this));
        this.setHTML(this.root.innerHTML);
      }
      Document2.prototype.addFormat = function(name, config) {
        if (!_.isObject(config)) {
          config = Format.FORMATS[name];
        }
        if (this.formats[name] != null) {
          console.warn("Overwriting format", name, this.formats[name]);
        }
        return this.formats[name] = new Format(this.root.ownerDocument, config);
      };
      Document2.prototype.appendLine = function(lineNode) {
        return this.insertLineBefore(lineNode, null);
      };
      Document2.prototype.findLeafAt = function(index, inclusive) {
        var line, offset, _ref;
        _ref = this.findLineAt(index), line = _ref[0], offset = _ref[1];
        if (line != null) {
          return line.findLeafAt(offset, inclusive);
        } else {
          return [null, offset];
        }
      };
      Document2.prototype.findLine = function(node) {
        var line;
        while (node != null && dom.BLOCK_TAGS[node.tagName] == null) {
          node = node.parentNode;
        }
        line = node != null ? this.lineMap[node.id] : null;
        if ((line != null ? line.node : void 0) === node) {
          return line;
        } else {
          return null;
        }
      };
      Document2.prototype.findLineAt = function(index) {
        var curLine, length;
        if (!(this.lines.length > 0)) {
          return [null, index];
        }
        length = this.toDelta().length();
        if (index === length) {
          return [this.lines.last, this.lines.last.length];
        }
        if (index > length) {
          return [null, index - length];
        }
        curLine = this.lines.first;
        while (curLine != null) {
          if (index < curLine.length) {
            return [curLine, index];
          }
          index -= curLine.length;
          curLine = curLine.next;
        }
        return [null, index];
      };
      Document2.prototype.insertLineBefore = function(newLineNode, refLine) {
        var line;
        line = new Line(this, newLineNode);
        if (refLine != null) {
          if (!dom(newLineNode.parentNode).isElement()) {
            this.root.insertBefore(newLineNode, refLine.node);
          }
          this.lines.insertAfter(refLine.prev, line);
        } else {
          if (!dom(newLineNode.parentNode).isElement()) {
            this.root.appendChild(newLineNode);
          }
          this.lines.append(line);
        }
        this.lineMap[line.id] = line;
        return line;
      };
      Document2.prototype.mergeLines = function(line, lineToMerge) {
        if (lineToMerge.length > 1) {
          if (line.length === 1) {
            dom(line.leaves.last.node).remove();
          }
          _.each(dom(lineToMerge.node).childNodes(), function(child) {
            if (child.tagName !== dom.DEFAULT_BREAK_TAG) {
              return line.node.appendChild(child);
            }
          });
        }
        this.removeLine(lineToMerge);
        return line.rebuild();
      };
      Document2.prototype.optimizeLines = function() {
        return _.each(this.lines.toArray(), function(line, i) {
          line.optimize();
          return true;
        });
      };
      Document2.prototype.rebuild = function() {
        var lineNode, lines, _results;
        lines = this.lines.toArray();
        lineNode = this.root.firstChild;
        if (lineNode != null && dom.LIST_TAGS[lineNode.tagName] != null) {
          lineNode = lineNode.firstChild;
        }
        _.each(lines, /* @__PURE__ */ function(_this) {
          return function(line, index) {
            var newLine, _ref;
            while (line.node !== lineNode) {
              if (line.node.parentNode === _this.root || ((_ref = line.node.parentNode) != null ? _ref.parentNode : void 0) === _this.root) {
                lineNode = Normalizer.normalizeLine(lineNode);
                newLine = _this.insertLineBefore(lineNode, line);
                lineNode = dom(lineNode).nextLineNode(_this.root);
              } else {
                return _this.removeLine(line);
              }
            }
            if (line.outerHTML !== lineNode.outerHTML) {
              line.node = Normalizer.normalizeLine(line.node);
              line.rebuild();
            }
            return lineNode = dom(lineNode).nextLineNode(_this.root);
          };
        }(this));
        _results = [];
        while (lineNode != null) {
          lineNode = Normalizer.normalizeLine(lineNode);
          this.appendLine(lineNode);
          _results.push(lineNode = dom(lineNode).nextLineNode(this.root));
        }
        return _results;
      };
      Document2.prototype.removeLine = function(line) {
        if (line.node.parentNode != null) {
          if (dom.LIST_TAGS[line.node.parentNode.tagName] && line.node.parentNode.childNodes.length === 1) {
            dom(line.node.parentNode).remove();
          } else {
            dom(line.node).remove();
          }
        }
        delete this.lineMap[line.id];
        return this.lines.remove(line);
      };
      Document2.prototype.setHTML = function(html) {
        html = Normalizer.stripComments(html);
        html = Normalizer.stripWhitespace(html);
        this.root.innerHTML = html;
        this.lines = new LinkedList();
        this.lineMap = {};
        return this.rebuild();
      };
      Document2.prototype.splitLine = function(line, offset) {
        var lineNode1, lineNode2, newLine, _ref;
        offset = Math.min(offset, line.length - 1);
        _ref = dom(line.node).split(offset, true), lineNode1 = _ref[0], lineNode2 = _ref[1];
        line.node = lineNode1;
        line.rebuild();
        newLine = this.insertLineBefore(lineNode2, line.next);
        newLine.formats = _.clone(line.formats);
        newLine.resetContent();
        return newLine;
      };
      Document2.prototype.toDelta = function() {
        var delta, lines;
        lines = this.lines.toArray();
        delta = new Delta();
        lines.forEach(function(line) {
          return line.delta.ops.forEach(function(op) {
            return delta.push(op);
          });
        });
        return delta;
      };
      return Document2;
    }();
    module.exports = Document;
  }
});

// node_modules/quilljs/lib/core/renderer.js
var require_renderer = __commonJS({
  "node_modules/quilljs/lib/core/renderer.js"(exports, module) {
    var DEFAULT_STYLES;
    var LIST_STYLES;
    var Normalizer;
    var Renderer;
    var dom;
    var rule;
    var _;
    _ = require_lodash();
    dom = require_dom();
    Normalizer = require_normalizer();
    DEFAULT_STYLES = {
      "html": {
        "height": "100%",
        "width": "100%"
      },
      "body": {
        "box-sizing": "border-box",
        "cursor": "text",
        "font-family": "'Helvetica', 'Arial', sans-serif",
        "font-size": "13px",
        "height": "100%",
        "line-height": "1.42",
        "margin": "0px",
        "overflow-x": "hidden",
        "overflow-y": "auto",
        "padding": "12px 15px"
      },
      ".editor-container": {
        "height": "100%",
        "outline": "none",
        "position": "relative",
        "tab-size": "4",
        "white-space": "pre-wrap"
      },
      ".editor-container div": {
        "margin": "0",
        "padding": "0"
      },
      ".editor-container a": {
        "text-decoration": "underline"
      },
      ".editor-container b": {
        "font-weight": "bold"
      },
      ".editor-container i": {
        "font-style": "italic"
      },
      ".editor-container s": {
        "text-decoration": "line-through"
      },
      ".editor-container u": {
        "text-decoration": "underline"
      },
      ".editor-container img": {
        "max-width": "100%"
      },
      ".editor-container blockquote": {
        "margin": "0 0 0 2em",
        "padding": "0"
      },
      ".editor-container ol": {
        "margin": "0 0 0 2em",
        "padding": "0",
        "list-style-type": "decimal"
      },
      ".editor-container ul": {
        "margin": "0 0 0 2em",
        "padding": "0",
        "list-style-type": "disc"
      }
    };
    LIST_STYLES = ["decimal", "lower-alpha", "lower-roman"];
    rule = ".editor-container ol > li";
    _.each([1, 2, 3, 4, 5, 6, 7, 8, 9], function(i) {
      rule += " > ol";
      DEFAULT_STYLES[rule] = {
        "list-style-type": LIST_STYLES[i % 3]
      };
      return rule += " > li";
    });
    if (dom.isIE(10)) {
      DEFAULT_STYLES[dom.DEFAULT_BREAK_TAG] = {
        "display": "none"
      };
    }
    Renderer = function() {
      Renderer2.objToCss = function(obj) {
        return _.map(obj, function(value, key) {
          var innerStr;
          innerStr = _.map(value, function(innerValue, innerKey) {
            return "" + innerKey + ": " + innerValue + ";";
          }).join(" ");
          return "" + key + " { " + innerStr + " }";
        }).join("\n");
      };
      Renderer2.buildFrame = function(container) {
        var iframe, iframeDoc, root;
        iframe = container.ownerDocument.createElement("iframe");
        dom(iframe).attributes({
          frameBorder: "0",
          height: "100%",
          width: "100%",
          title: "Quill Rich Text Editor",
          role: "presentation"
        });
        container.appendChild(iframe);
        iframeDoc = iframe.contentWindow.document;
        iframeDoc.open();
        iframeDoc.write("<!DOCTYPE html>");
        iframeDoc.close();
        root = iframeDoc.createElement("div");
        iframeDoc.body.appendChild(root);
        return [root, iframe];
      };
      function Renderer2(container, options) {
        var _ref;
        this.container = container;
        this.options = options != null ? options : {};
        this.container.innerHTML = "";
        _ref = Renderer2.buildFrame(this.container), this.root = _ref[0], this.iframe = _ref[1];
        this.root.setAttribute("id", this.options.id);
        this.iframe.setAttribute("name", this.options.id);
        dom(this.root).addClass("editor-container");
        dom(this.container).addClass("ql-container");
        if (dom.isIOS()) {
          dom(this.container).styles({
            "overflow": "auto",
            "-webkit-overflow-scrolling": "touch"
          });
        }
        this.addStyles(DEFAULT_STYLES);
        if (this.options.styles != null) {
          _.defer(_.bind(this.addStyles, this, this.options.styles));
        }
      }
      Renderer2.prototype.addContainer = function(className, before) {
        var container, refNode;
        if (before == null) {
          before = false;
        }
        refNode = before ? this.root : null;
        container = this.root.ownerDocument.createElement("div");
        dom(container).addClass(className);
        this.root.parentNode.insertBefore(container, refNode);
        return container;
      };
      Renderer2.prototype.addStyles = function(css) {
        var link, style;
        if (typeof css === "object") {
          style = this.root.ownerDocument.createElement("style");
          style.type = "text/css";
          css = Renderer2.objToCss(css);
          style.appendChild(this.root.ownerDocument.createTextNode(css));
          return this.root.ownerDocument.head.appendChild(style);
        } else if (typeof css === "string") {
          link = this.root.ownerDocument.createElement("link");
          dom(link).attributes({
            type: "text/css",
            rel: "stylesheet",
            href: css
          });
          return this.root.ownerDocument.head.appendChild(link);
        }
      };
      return Renderer2;
    }();
    module.exports = Renderer;
  }
});

// node_modules/quilljs/lib/lib/range.js
var require_range = __commonJS({
  "node_modules/quilljs/lib/lib/range.js"(exports, module) {
    var Range2;
    var _;
    _ = require_lodash();
    Range2 = function() {
      Range3.compare = function(r1, r2) {
        if (r1 === r2) {
          return true;
        }
        if (!(r1 != null && r2 != null)) {
          return false;
        }
        return r1.equals(r2);
      };
      function Range3(start, end) {
        this.start = start;
        this.end = end;
      }
      Range3.prototype.equals = function(range) {
        if (range == null) {
          return false;
        }
        return this.start === range.start && this.end === range.end;
      };
      Range3.prototype.shift = function(index, length) {
        var _ref;
        return _ref = _.map([this.start, this.end], function(pos) {
          if (index > pos) {
            return pos;
          }
          if (length >= 0) {
            return pos + length;
          } else {
            return Math.max(index, pos + length);
          }
        }), this.start = _ref[0], this.end = _ref[1], _ref;
      };
      Range3.prototype.isCollapsed = function() {
        return this.start === this.end;
      };
      return Range3;
    }();
    module.exports = Range2;
  }
});

// node_modules/quilljs/lib/core/selection.js
var require_selection = __commonJS({
  "node_modules/quilljs/lib/core/selection.js"(exports, module) {
    var Leaf;
    var Normalizer;
    var Range2;
    var Selection;
    var dom;
    var _;
    _ = require_lodash();
    dom = require_dom();
    Leaf = require_leaf();
    Normalizer = require_normalizer();
    Range2 = require_range();
    Selection = function() {
      function Selection2(doc, iframe, emitter) {
        this.doc = doc;
        this.iframe = iframe;
        this.emitter = emitter;
        this.document = this.doc.root.ownerDocument;
        this.focus = false;
        this.range = new Range2(0, 0);
        this.nullDelay = false;
        this.update("silent");
      }
      Selection2.prototype.checkFocus = function() {
        return this.document.activeElement === this.doc.root && document.activeElement === this.iframe;
      };
      Selection2.prototype.getRange = function(ignoreFocus) {
        var end, nativeRange, start;
        if (ignoreFocus == null) {
          ignoreFocus = false;
        }
        if (this.checkFocus()) {
          nativeRange = this._getNativeRange();
          if (nativeRange == null) {
            return null;
          }
          start = this._positionToIndex(nativeRange.startContainer, nativeRange.startOffset);
          if (nativeRange.startContainer === nativeRange.endContainer && nativeRange.startOffset === nativeRange.endOffset) {
            end = start;
          } else {
            end = this._positionToIndex(nativeRange.endContainer, nativeRange.endOffset);
          }
          return new Range2(Math.min(start, end), Math.max(start, end));
        } else if (ignoreFocus) {
          return this.range;
        } else {
          return null;
        }
      };
      Selection2.prototype.preserve = function(fn) {
        var endNode, endOffset, nativeRange, startNode, startOffset, _ref, _ref1, _ref2, _ref3;
        nativeRange = this._getNativeRange();
        if (nativeRange != null && this.checkFocus()) {
          _ref = this._encodePosition(nativeRange.startContainer, nativeRange.startOffset), startNode = _ref[0], startOffset = _ref[1];
          _ref1 = this._encodePosition(nativeRange.endContainer, nativeRange.endOffset), endNode = _ref1[0], endOffset = _ref1[1];
          fn();
          _ref2 = this._decodePosition(startNode, startOffset), startNode = _ref2[0], startOffset = _ref2[1];
          _ref3 = this._decodePosition(endNode, endOffset), endNode = _ref3[0], endOffset = _ref3[1];
          return this._setNativeRange(startNode, startOffset, endNode, endOffset);
        } else {
          return fn();
        }
      };
      Selection2.prototype.setRange = function(range, source) {
        var endNode, endOffset, startNode, startOffset, _ref, _ref1, _ref2;
        if (range != null) {
          _ref = this._indexToPosition(range.start), startNode = _ref[0], startOffset = _ref[1];
          if (range.isCollapsed()) {
            _ref1 = [startNode, startOffset], endNode = _ref1[0], endOffset = _ref1[1];
          } else {
            _ref2 = this._indexToPosition(range.end), endNode = _ref2[0], endOffset = _ref2[1];
          }
          this._setNativeRange(startNode, startOffset, endNode, endOffset);
        } else {
          this._setNativeRange(null);
        }
        return this.update(source);
      };
      Selection2.prototype.shiftAfter = function(index, length, fn) {
        var range;
        range = this.getRange();
        fn();
        if (range != null) {
          range.shift(index, length);
          return this.setRange(range, "silent");
        }
      };
      Selection2.prototype.update = function(source) {
        var emit, focus, range, toEmit;
        focus = this.checkFocus();
        range = this.getRange(true);
        emit = source !== "silent" && (!Range2.compare(range, this.range) || focus !== this.focus);
        toEmit = focus ? range : null;
        if (toEmit === null && source === "user" && !this.nullDelay) {
          return this.nullDelay = true;
        } else {
          this.nullDelay = false;
          this.range = range;
          this.focus = focus;
          if (emit) {
            return this.emitter.emit(this.emitter.constructor.events.SELECTION_CHANGE, toEmit, source);
          }
        }
      };
      Selection2.prototype._decodePosition = function(node, offset) {
        var childIndex;
        if (dom(node).isElement()) {
          childIndex = _.indexOf(dom(node.parentNode).childNodes(), node);
          offset += childIndex;
          node = node.parentNode;
        }
        return [node, offset];
      };
      Selection2.prototype._encodePosition = function(node, offset) {
        var text;
        while (true) {
          if (dom(node).isTextNode() || node.tagName === dom.DEFAULT_BREAK_TAG || dom.EMBED_TAGS[node.tagName] != null) {
            return [node, offset];
          } else if (offset < node.childNodes.length) {
            node = node.childNodes[offset];
            offset = 0;
          } else if (node.childNodes.length === 0) {
            if (Normalizer.TAGS[node.tagName] == null) {
              text = node.ownerDocument.createTextNode("");
              node.appendChild(text);
              node = text;
            }
            return [node, 0];
          } else {
            node = node.lastChild;
            if (dom(node).isElement()) {
              if (node.tagName === dom.DEFAULT_BREAK_TAG || dom.EMBED_TAGS[node.tagName] != null) {
                return [node, 1];
              } else {
                offset = node.childNodes.length;
              }
            } else {
              return [node, dom(node).length()];
            }
          }
        }
      };
      Selection2.prototype._getNativeRange = function() {
        var range, selection;
        selection = this.document.getSelection();
        if ((selection != null ? selection.rangeCount : void 0) > 0) {
          range = selection.getRangeAt(0);
          if (dom(range.startContainer).isAncestor(this.doc.root, true)) {
            if (range.startContainer === range.endContainer || dom(range.endContainer).isAncestor(this.doc.root, true)) {
              return range;
            }
          }
        }
        return null;
      };
      Selection2.prototype._indexToPosition = function(index) {
        var leaf, offset, _ref;
        if (this.doc.lines.length === 0) {
          return [this.doc.root, 0];
        }
        _ref = this.doc.findLeafAt(index, true), leaf = _ref[0], offset = _ref[1];
        return this._decodePosition(leaf.node, offset);
      };
      Selection2.prototype._positionToIndex = function(node, offset) {
        var leaf, leafNode, leafOffset, line, lineOffset, _ref;
        _ref = this._encodePosition(node, offset), leafNode = _ref[0], offset = _ref[1];
        line = this.doc.findLine(leafNode);
        if (line == null) {
          return 0;
        }
        leaf = line.findLeaf(leafNode);
        lineOffset = 0;
        while (line.prev != null) {
          line = line.prev;
          lineOffset += line.length;
        }
        if (leaf == null) {
          return lineOffset;
        }
        leafOffset = 0;
        while (leaf.prev != null) {
          leaf = leaf.prev;
          leafOffset += leaf.length;
        }
        return lineOffset + leafOffset + offset;
      };
      Selection2.prototype._setNativeRange = function(startNode, startOffset, endNode, endOffset) {
        var nativeRange, selection;
        selection = this.document.getSelection();
        if (!selection) {
          return;
        }
        if (startNode != null) {
          if (!this.checkFocus()) {
            this.doc.root.focus();
          }
          nativeRange = this._getNativeRange();
          if (nativeRange == null || startNode !== nativeRange.startContainer || startOffset !== nativeRange.startOffset || endNode !== nativeRange.endContainer || endOffset !== nativeRange.endOffset) {
            selection.removeAllRanges();
            nativeRange = this.document.createRange();
            nativeRange.setStart(startNode, startOffset);
            nativeRange.setEnd(endNode, endOffset);
            selection.addRange(nativeRange);
            if (!this.checkFocus()) {
              return this.doc.root.focus();
            }
          }
        } else {
          selection.removeAllRanges();
          return this.doc.root.blur();
        }
      };
      return Selection2;
    }();
    module.exports = Selection;
  }
});

// node_modules/quilljs/lib/core/editor.js
var require_editor = __commonJS({
  "node_modules/quilljs/lib/core/editor.js"(exports, module) {
    var Document;
    var Editor;
    var Line;
    var Renderer;
    var Selection;
    var dom;
    var _;
    _ = require_lodash();
    dom = require_dom();
    Document = require_document();
    Line = require_line();
    Renderer = require_renderer();
    Selection = require_selection();
    Editor = function() {
      Editor2.sources = {
        API: "api",
        SILENT: "silent",
        USER: "user"
      };
      function Editor2(iframeContainer, quill, options) {
        this.iframeContainer = iframeContainer;
        this.quill = quill;
        this.options = options != null ? options : {};
        this.renderer = new Renderer(this.iframeContainer, this.options);
        dom(this.iframeContainer).on("focus", this.focus.bind(this));
        this.root = this.renderer.root;
        this.doc = new Document(this.root, this.options);
        this.delta = this.doc.toDelta();
        this.selection = new Selection(this.doc, this.renderer.iframe, this.quill);
        this.timer = setInterval(_.bind(this.checkUpdate, this), this.options.pollInterval);
        if (!this.options.readOnly) {
          this.enable();
        }
      }
      Editor2.prototype.disable = function() {
        return this.enable(false);
      };
      Editor2.prototype.enable = function(enabled) {
        if (enabled == null) {
          enabled = true;
        }
        return this.root.setAttribute("contenteditable", enabled);
      };
      Editor2.prototype.applyDelta = function(delta, source) {
        var localDelta;
        localDelta = this._update();
        if (localDelta) {
          delta = localDelta.transform(delta, true);
          localDelta = delta.transform(localDelta, false);
        }
        if (delta.ops.length > 0) {
          delta = this._trackDelta(/* @__PURE__ */ function(_this) {
            return function() {
              var index;
              index = 0;
              _.each(delta.ops, function(op) {
                if (_.isString(op.insert)) {
                  _this._insertAt(index, op.insert, op.attributes);
                  return index += op.insert.length;
                } else if (_.isNumber(op.insert)) {
                  _this._insertAt(index, dom.EMBED_TEXT, op.attributes);
                  return index += 1;
                } else if (_.isNumber(op["delete"])) {
                  return _this._deleteAt(index, op["delete"]);
                } else if (_.isNumber(op.retain)) {
                  _.each(op.attributes, function(value, name) {
                    return _this._formatAt(index, op.retain, name, value);
                  });
                  return index += op.retain;
                }
              });
              return _this.selection.shiftAfter(0, 0, _.bind(_this.doc.optimizeLines, _this.doc));
            };
          }(this));
          this.delta = this.doc.toDelta();
          this.innerHTML = this.root.innerHTML;
          if (delta && source !== Editor2.sources.SILENT) {
            this.quill.emit(this.quill.constructor.events.TEXT_CHANGE, delta, source);
          }
        }
        if (localDelta && localDelta.ops.length > 0 && source !== Editor2.sources.SILENT) {
          return this.quill.emit(this.quill.constructor.events.TEXT_CHANGE, localDelta, Editor2.sources.USER);
        }
      };
      Editor2.prototype.checkUpdate = function(source) {
        var delta;
        if (source == null) {
          source = "user";
        }
        if (this.renderer.iframe.parentNode == null || this.root.parentNode == null) {
          return clearInterval(this.timer);
        }
        delta = this._update();
        if (delta) {
          this.delta.compose(delta);
          this.quill.emit(this.quill.constructor.events.TEXT_CHANGE, delta, source);
        }
        if (delta) {
          source = Editor2.sources.SILENT;
        }
        return this.selection.update(source);
      };
      Editor2.prototype.focus = function() {
        if (dom.isIE(11)) {
          this.selection.setRange(this.selection.range);
        }
        if (dom.isIOS()) {
          this.renderer.iframe.focus();
        }
        return this.root.focus();
      };
      Editor2.prototype.getDelta = function() {
        return this.delta;
      };
      Editor2.prototype._deleteAt = function(index, length) {
        if (length <= 0) {
          return;
        }
        return this.selection.shiftAfter(index, -1 * length, /* @__PURE__ */ function(_this) {
          return function() {
            var curLine, deleteLength, firstLine, mergeFirstLine, nextLine, offset, _ref;
            _ref = _this.doc.findLineAt(index), firstLine = _ref[0], offset = _ref[1];
            curLine = firstLine;
            mergeFirstLine = firstLine.length - offset <= length && offset > 0;
            while (curLine != null && length > 0) {
              nextLine = curLine.next;
              deleteLength = Math.min(curLine.length - offset, length);
              if (offset === 0 && length >= curLine.length) {
                _this.doc.removeLine(curLine);
              } else {
                curLine.deleteText(offset, deleteLength);
              }
              length -= deleteLength;
              curLine = nextLine;
              offset = 0;
            }
            if (mergeFirstLine && firstLine.next) {
              return _this.doc.mergeLines(firstLine, firstLine.next);
            }
          };
        }(this));
      };
      Editor2.prototype._formatAt = function(index, length, name, value) {
        return this.selection.shiftAfter(index, 0, /* @__PURE__ */ function(_this) {
          return function() {
            var formatLength, line, offset, _ref, _results;
            _ref = _this.doc.findLineAt(index), line = _ref[0], offset = _ref[1];
            _results = [];
            while (line != null && length > 0) {
              formatLength = Math.min(length, line.length - offset - 1);
              line.formatText(offset, formatLength, name, value);
              length -= formatLength;
              if (length > 0) {
                line.format(name, value);
              }
              length -= 1;
              offset = 0;
              _results.push(line = line.next);
            }
            return _results;
          };
        }(this));
      };
      Editor2.prototype._insertAt = function(index, text, formatting) {
        if (formatting == null) {
          formatting = {};
        }
        return this.selection.shiftAfter(index, text.length, /* @__PURE__ */ function(_this) {
          return function() {
            var line, lineTexts, offset, _ref;
            text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
            lineTexts = text.split("\n");
            _ref = _this.doc.findLineAt(index), line = _ref[0], offset = _ref[1];
            return _.each(lineTexts, function(lineText, i) {
              var nextLine;
              if (line == null || line.length <= offset) {
                if (i < lineTexts.length - 1 || lineText.length > 0) {
                  line = _this.doc.appendLine(_this.root.ownerDocument.createElement(dom.DEFAULT_BLOCK_TAG));
                  offset = 0;
                  line.insertText(offset, lineText, formatting);
                  line.format(formatting);
                  nextLine = null;
                }
              } else {
                line.insertText(offset, lineText, formatting);
                if (i < lineTexts.length - 1) {
                  nextLine = _this.doc.splitLine(line, offset + lineText.length);
                  _.each(_.defaults({}, formatting, line.formats), function(value, format) {
                    return line.format(format, formatting[format]);
                  });
                  offset = 0;
                }
              }
              return line = nextLine;
            });
          };
        }(this));
      };
      Editor2.prototype._trackDelta = function(fn) {
        var delta, newDelta;
        fn();
        newDelta = this.doc.toDelta();
        delta = this.delta.diff(newDelta);
        return delta;
      };
      Editor2.prototype._update = function() {
        var delta;
        if (this.innerHTML === this.root.innerHTML) {
          return false;
        }
        delta = this._trackDelta(/* @__PURE__ */ function(_this) {
          return function() {
            _this.selection.preserve(_.bind(_this.doc.rebuild, _this.doc));
            return _this.selection.shiftAfter(0, 0, _.bind(_this.doc.optimizeLines, _this.doc));
          };
        }(this));
        this.innerHTML = this.root.innerHTML;
        if (delta.ops.length > 0) {
          return delta;
        } else {
          return false;
        }
      };
      return Editor2;
    }();
    module.exports = Editor;
  }
});

// node_modules/quilljs/lib/themes/default.js
var require_default = __commonJS({
  "node_modules/quilljs/lib/themes/default.js"(exports, module) {
    var DefaultTheme;
    DefaultTheme = function() {
      DefaultTheme2.OPTIONS = {};
      function DefaultTheme2(quill) {
        this.quill = quill;
        this.editor = this.quill.editor;
        this.editorContainer = this.editor.root;
      }
      return DefaultTheme2;
    }();
    module.exports = DefaultTheme;
  }
});

// node_modules/quilljs/lib/lib/picker.js
var require_picker = __commonJS({
  "node_modules/quilljs/lib/lib/picker.js"(exports, module) {
    var Normalizer;
    var Picker;
    var dom;
    var _;
    _ = require_lodash();
    dom = require_dom();
    Normalizer = require_normalizer();
    Picker = function() {
      Picker2.TEMPLATE = '<span class="ql-picker-label"></span><span class="ql-picker-options"></span>';
      function Picker2(select) {
        this.select = select;
        this.container = this.select.ownerDocument.createElement("span");
        this.buildPicker();
        dom(this.container).addClass("ql-picker");
        this.select.style.display = "none";
        this.select.parentNode.insertBefore(this.container, this.select);
        dom(this.select.ownerDocument).on("click", /* @__PURE__ */ function(_this) {
          return function() {
            _this.close();
            return true;
          };
        }(this));
        dom(this.label).on("click", /* @__PURE__ */ function(_this) {
          return function() {
            _.defer(function() {
              return dom(_this.container).toggleClass("ql-expanded");
            });
            return false;
          };
        }(this));
        dom(this.select).on("change", /* @__PURE__ */ function(_this) {
          return function() {
            var item, option;
            if (_this.select.selectedIndex > -1) {
              item = _this.container.querySelectorAll(".ql-picker-item")[_this.select.selectedIndex];
              option = _this.select.options[_this.select.selectedIndex];
            }
            _this.selectItem(item, false);
            return dom(_this.label).toggleClass("ql-active", option !== dom(_this.select)["default"]());
          };
        }(this));
      }
      Picker2.prototype.buildItem = function(picker, option, index) {
        var item;
        item = this.select.ownerDocument.createElement("span");
        item.setAttribute("data-value", option.getAttribute("value"));
        dom(item).addClass("ql-picker-item").text(dom(option).text()).on("click", /* @__PURE__ */ function(_this) {
          return function() {
            _this.selectItem(item, true);
            return _this.close();
          };
        }(this));
        if (this.select.selectedIndex === index) {
          this.selectItem(item, false);
        }
        return item;
      };
      Picker2.prototype.buildPicker = function() {
        var picker;
        _.each(dom(this.select).attributes(), /* @__PURE__ */ function(_this) {
          return function(value, name) {
            return _this.container.setAttribute(name, value);
          };
        }(this));
        this.container.innerHTML = Normalizer.stripWhitespace(Picker2.TEMPLATE);
        this.label = this.container.querySelector(".ql-picker-label");
        picker = this.container.querySelector(".ql-picker-options");
        return _.each(this.select.options, /* @__PURE__ */ function(_this) {
          return function(option, i) {
            var item;
            item = _this.buildItem(picker, option, i);
            return picker.appendChild(item);
          };
        }(this));
      };
      Picker2.prototype.close = function() {
        return dom(this.container).removeClass("ql-expanded");
      };
      Picker2.prototype.selectItem = function(item, trigger) {
        var selected, value;
        selected = this.container.querySelector(".ql-selected");
        if (selected != null) {
          dom(selected).removeClass("ql-selected");
        }
        if (item != null) {
          value = item.getAttribute("data-value");
          dom(item).addClass("ql-selected");
          dom(this.label).text(dom(item).text());
          dom(this.select).option(value, trigger);
          return this.label.setAttribute("data-value", value);
        } else {
          this.label.innerHTML = "&nbsp;";
          return this.label.removeAttribute("data-value");
        }
      };
      return Picker2;
    }();
    module.exports = Picker;
  }
});

// node_modules/quilljs/lib/lib/color-picker.js
var require_color_picker = __commonJS({
  "node_modules/quilljs/lib/lib/color-picker.js"(exports, module) {
    var ColorPicker;
    var Picker;
    var dom;
    var __hasProp = {}.hasOwnProperty;
    var __extends = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    dom = require_dom();
    Picker = require_picker();
    ColorPicker = function(_super) {
      __extends(ColorPicker2, _super);
      function ColorPicker2() {
        ColorPicker2.__super__.constructor.apply(this, arguments);
        dom(this.container).addClass("ql-color-picker");
      }
      ColorPicker2.prototype.buildItem = function(picker, option, index) {
        var item;
        item = ColorPicker2.__super__.buildItem.call(this, picker, option, index);
        item.style.backgroundColor = option.value;
        return item;
      };
      return ColorPicker2;
    }(Picker);
    module.exports = ColorPicker;
  }
});

// node_modules/quilljs/lib/themes/snow/index.js
var require_snow = __commonJS({
  "node_modules/quilljs/lib/themes/snow/index.js"(exports, module) {
    var ColorPicker;
    var DefaultTheme;
    var Picker;
    var SnowTheme;
    var dom;
    var _;
    var __hasProp = {}.hasOwnProperty;
    var __extends = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    _ = require_lodash();
    ColorPicker = require_color_picker();
    DefaultTheme = require_default();
    dom = require_dom();
    Picker = require_picker();
    SnowTheme = function(_super) {
      __extends(SnowTheme2, _super);
      SnowTheme2.COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008A00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
      SnowTheme2.OPTIONS = {
        "multi-cursor": {
          template: '<span class="cursor-flag"> <span class="cursor-triangle top"></span> <span class="cursor-name"></span> <span class="cursor-triangle bottom"></span> </span> <span class="cursor-caret"></span>'
        }
      };
      SnowTheme2.STYLES = {
        ".snow .image-tooltip-container a": {
          "border": "1px solid #06c"
        },
        ".snow .image-tooltip-container a.insert": {
          "background-color": "#06c",
          "color": "#fff"
        },
        ".snow .cursor-name": {
          "border-radius": "4px",
          "font-size": "11px",
          "font-family": "Arial",
          "margin-left": "-50%",
          "padding": "4px 10px"
        },
        ".snow .cursor-triangle": {
          "border-left": "4px solid transparent",
          "border-right": "4px solid transparent",
          "height": "0px",
          "margin-left": "-3px",
          "width": "0px"
        },
        ".snow .cursor.left .cursor-name": {
          "margin-left": "-8px"
        },
        ".snow .cursor.right .cursor-flag": {
          "right": "auto"
        },
        ".snow .cursor.right .cursor-name": {
          "margin-left": "-100%",
          "margin-right": "-8px"
        },
        ".snow .cursor-triangle.bottom": {
          "border-top": "4px solid transparent",
          "display": "block",
          "margin-bottom": "-1px"
        },
        ".snow .cursor-triangle.top": {
          "border-bottom": "4px solid transparent",
          "display": "none",
          "margin-top": "-1px"
        },
        ".snow .cursor.top .cursor-triangle.bottom": {
          "display": "none"
        },
        ".snow .cursor.top .cursor-triangle.top": {
          "display": "block"
        },
        ".snow a": {
          "color": "#06c"
        },
        ".snow .tooltip": {
          "border": "1px solid #ccc",
          "box-shadow": "0px 0px 5px #ddd",
          "color": "#222"
        },
        ".snow .tooltip a": {
          "color": "#06c"
        },
        ".snow .tooltip .input": {
          "border": "1px solid #ccc",
          "margin": "0px",
          "padding": "5px"
        },
        ".snow .image-tooltip-container .preview": {
          "border-color": "#ccc",
          "color": "#ccc"
        },
        ".snow .link-tooltip-container a, .snow .link-tooltip-container span": {
          "display": "inline-block",
          "line-height": "25px"
        }
      };
      function SnowTheme2(quill) {
        this.quill = quill;
        SnowTheme2.__super__.constructor.apply(this, arguments);
        this.quill.addStyles(SnowTheme2.STYLES);
        this.pickers = [];
        this.quill.on(this.quill.constructor.events.SELECTION_CHANGE, /* @__PURE__ */ function(_this) {
          return function(range) {
            if (range != null) {
              return _.invoke(_this.pickers, "close");
            }
          };
        }(this));
        dom(this.quill.root.ownerDocument.body).addClass("snow");
        this.quill.onModuleLoad("multi-cursor", _.bind(this.extendMultiCursor, this));
        this.quill.onModuleLoad("toolbar", _.bind(this.extendToolbar, this));
      }
      SnowTheme2.prototype.extendMultiCursor = function(module2) {
        return module2.on(module2.constructor.events.CURSOR_ADDED, function(cursor) {
          var bottomTriangle, topTriangle;
          bottomTriangle = cursor.elem.querySelector(".cursor-triangle.bottom");
          topTriangle = cursor.elem.querySelector(".cursor-triangle.top");
          return bottomTriangle.style.borderTopColor = topTriangle.style.borderBottomColor = cursor.color;
        });
      };
      SnowTheme2.prototype.extendToolbar = function(module2) {
        _.each(["color", "background", "font", "size", "align"], /* @__PURE__ */ function(_this) {
          return function(format) {
            var picker, select;
            select = module2.container.querySelector(".ql-" + format);
            if (select == null) {
              return;
            }
            switch (format) {
              case "font":
              case "size":
              case "align":
                picker = new Picker(select);
                break;
              case "color":
              case "background":
                picker = new ColorPicker(select);
                _.each(picker.container.querySelectorAll(".ql-picker-item"), function(item, i) {
                  if (i < 7) {
                    return dom(item).addClass("ql-primary-color");
                  }
                });
            }
            if (picker != null) {
              return _this.pickers.push(picker);
            }
          };
        }(this));
        return _.each(dom(module2.container).textNodes(), function(node) {
          if (dom(node).text().trim().length === 0) {
            return dom(node).remove();
          }
        });
      };
      return SnowTheme2;
    }(DefaultTheme);
    module.exports = SnowTheme;
  }
});

// node_modules/quilljs/lib/quill.js
var require_quill = __commonJS({
  "node_modules/quilljs/lib/quill.js"(exports, module) {
    var Delta;
    var Editor;
    var EventEmitter2;
    var Format;
    var Quill;
    var Range2;
    var dom;
    var pkg;
    var _;
    var __hasProp = {}.hasOwnProperty;
    var __extends = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var __slice = [].slice;
    _ = require_lodash();
    pkg = require_package();
    Delta = require_rich_text().Delta;
    EventEmitter2 = require_eventemitter2().EventEmitter2;
    dom = require_dom();
    Editor = require_editor();
    Format = require_format();
    Range2 = require_range();
    Quill = function(_super) {
      __extends(Quill2, _super);
      Quill2.version = pkg.version;
      Quill2.editors = [];
      Quill2.modules = [];
      Quill2.themes = [];
      Quill2.DEFAULTS = {
        formats: ["align", "bold", "italic", "strike", "underline", "color", "background", "font", "size", "link", "image", "bullet", "list"],
        modules: {
          "keyboard": true,
          "paste-manager": true,
          "undo-manager": true
        },
        pollInterval: 100,
        readOnly: false,
        theme: "default"
      };
      Quill2.events = {
        MODULE_INIT: "module-init",
        POST_EVENT: "post-event",
        PRE_EVENT: "pre-event",
        SELECTION_CHANGE: "selection-change",
        TEXT_CHANGE: "text-change"
      };
      Quill2.sources = Editor.sources;
      Quill2.registerModule = function(name, module2) {
        if (Quill2.modules[name] != null) {
          console.warn("Overwriting " + name + " module");
        }
        return Quill2.modules[name] = module2;
      };
      Quill2.registerTheme = function(name, theme) {
        if (Quill2.themes[name] != null) {
          console.warn("Overwriting " + name + " theme");
        }
        return Quill2.themes[name] = theme;
      };
      Quill2.require = function(name) {
        switch (name) {
          case "lodash":
            return _;
          case "delta":
            return Delta;
          case "dom":
            return dom;
          default:
            return null;
        }
      };
      function Quill2(container, options) {
        var html, moduleOptions, themeClass;
        if (options == null) {
          options = {};
        }
        if (_.isString(container)) {
          container = document.querySelector(container);
        }
        if (container == null) {
          throw new Error("Invalid Quill container");
        }
        moduleOptions = _.defaults(options.modules || {}, Quill2.DEFAULTS.modules);
        html = container.innerHTML;
        this.options = _.defaults(options, Quill2.DEFAULTS);
        this.options.modules = moduleOptions;
        this.options.id = this.id = "quill-" + (Quill2.editors.length + 1);
        this.options.emitter = this;
        this.modules = {};
        this.editor = new Editor(container, this, this.options);
        this.root = this.editor.doc.root;
        Quill2.editors.push(this);
        this.setHTML(html, Quill2.sources.SILENT);
        themeClass = Quill2.themes[this.options.theme];
        if (themeClass == null) {
          throw new Error("Cannot load " + this.options.theme + " theme. Are you sure you registered it?");
        }
        this.theme = new themeClass(this, this.options);
        _.each(this.options.modules, /* @__PURE__ */ function(_this) {
          return function(option, name) {
            return _this.addModule(name, option);
          };
        }(this));
      }
      Quill2.prototype.addContainer = function(className, before) {
        if (before == null) {
          before = false;
        }
        return this.editor.renderer.addContainer(className, before);
      };
      Quill2.prototype.addFormat = function(name, format) {
        return this.editor.doc.addFormat(name, format);
      };
      Quill2.prototype.addModule = function(name, options) {
        var moduleClass;
        moduleClass = Quill2.modules[name];
        if (moduleClass == null) {
          throw new Error("Cannot load " + name + " module. Are you sure you registered it?");
        }
        if (!_.isObject(options)) {
          options = {};
        }
        options = _.defaults(options, this.theme.constructor.OPTIONS[name] || {}, moduleClass.DEFAULTS || {});
        this.modules[name] = new moduleClass(this, options);
        this.emit(Quill2.events.MODULE_INIT, name, this.modules[name]);
        return this.modules[name];
      };
      Quill2.prototype.addStyles = function(styles) {
        return this.editor.renderer.addStyles(styles);
      };
      Quill2.prototype.deleteText = function(start, end, source) {
        var delta, formats, _ref;
        if (source == null) {
          source = Quill2.sources.API;
        }
        _ref = this._buildParams(start, end, {}, source), start = _ref[0], end = _ref[1], formats = _ref[2], source = _ref[3];
        if (!(end > start)) {
          return;
        }
        delta = new Delta().retain(start)["delete"](end - start);
        return this.editor.applyDelta(delta, source);
      };
      Quill2.prototype.emit = function() {
        var args, eventName;
        eventName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        Quill2.__super__.emit.apply(this, [Quill2.events.PRE_EVENT, eventName].concat(__slice.call(args)));
        Quill2.__super__.emit.apply(this, [eventName].concat(__slice.call(args)));
        return Quill2.__super__.emit.apply(this, [Quill2.events.POST_EVENT, eventName].concat(__slice.call(args)));
      };
      Quill2.prototype.focus = function() {
        return this.editor.focus();
      };
      Quill2.prototype.formatLine = function(start, end, name, value, source) {
        var formats, line, offset, _ref, _ref1;
        _ref = this._buildParams(start, end, name, value, source), start = _ref[0], end = _ref[1], formats = _ref[2], source = _ref[3];
        _ref1 = this.editor.doc.findLineAt(end), line = _ref1[0], offset = _ref1[1];
        if (line != null) {
          end += line.length - offset;
        }
        return this.formatText(start, end, formats, source);
      };
      Quill2.prototype.formatText = function(start, end, name, value, source) {
        var delta, formats, _ref;
        _ref = this._buildParams(start, end, name, value, source), start = _ref[0], end = _ref[1], formats = _ref[2], source = _ref[3];
        formats = _.reduce(formats, /* @__PURE__ */ function(_this) {
          return function(formats2, value2, name2) {
            var format;
            format = _this.editor.doc.formats[name2];
            if (!(value2 && value2 !== format.config["default"])) {
              formats2[name2] = null;
            }
            return formats2;
          };
        }(this), formats);
        delta = new Delta().retain(start).retain(end - start, formats);
        return this.editor.applyDelta(delta, source);
      };
      Quill2.prototype.getContents = function(start, end) {
        if (start == null) {
          start = 0;
        }
        if (end == null) {
          end = null;
        }
        if (_.isObject(start)) {
          end = start.end;
          start = start.start;
        }
        return this.editor.getDelta().slice(start, end);
      };
      Quill2.prototype.getHTML = function() {
        return this.root.innerHTML;
      };
      Quill2.prototype.getLength = function() {
        return this.editor.getDelta().length();
      };
      Quill2.prototype.getModule = function(name) {
        return this.modules[name];
      };
      Quill2.prototype.getSelection = function() {
        this.editor.checkUpdate();
        return this.editor.selection.getRange();
      };
      Quill2.prototype.getText = function(start, end) {
        if (start == null) {
          start = 0;
        }
        if (end == null) {
          end = null;
        }
        return _.map(this.getContents(start, end).ops, function(op) {
          if (_.isString(op.insert)) {
            return op.insert;
          } else {
            return "";
          }
        }).join("");
      };
      Quill2.prototype.insertEmbed = function(index, type, url, source) {
        return this.insertText(index, dom.EMBED_TEXT, type, url, source);
      };
      Quill2.prototype.insertText = function(index, text, name, value, source) {
        var delta, end, formats, _ref;
        _ref = this._buildParams(index, 0, name, value, source), index = _ref[0], end = _ref[1], formats = _ref[2], source = _ref[3];
        if (!(text.length > 0)) {
          return;
        }
        delta = new Delta().retain(index).insert(text, formats);
        return this.editor.applyDelta(delta, source);
      };
      Quill2.prototype.onModuleLoad = function(name, callback) {
        if (this.modules[name]) {
          return callback(this.modules[name]);
        }
        return this.on(Quill2.events.MODULE_INIT, function(moduleName, module2) {
          if (moduleName === name) {
            return callback(module2);
          }
        });
      };
      Quill2.prototype.prepareFormat = function(name, value) {
        var format, range;
        format = this.editor.doc.formats[name];
        if (format == null) {
          return;
        }
        range = this.getSelection();
        if (!(range != null ? range.isCollapsed() : void 0)) {
          return;
        }
        if (format.isType(Format.types.LINE)) {
          return this.formatLine(range, name, value, Quill2.sources.USER);
        } else {
          return format.prepare(value);
        }
      };
      Quill2.prototype.setContents = function(delta, source) {
        if (source == null) {
          source = Quill2.sources.API;
        }
        if (_.isArray(delta)) {
          delta = {
            ops: delta
          };
        }
        delta.ops.unshift({
          "delete": this.getLength()
        });
        return this.updateContents(delta, source);
      };
      Quill2.prototype.setHTML = function(html, source) {
        if (source == null) {
          source = Quill2.sources.API;
        }
        if (!html) {
          html = "<" + dom.DEFAULT_BLOCK_TAG + "><" + dom.DEFAULT_BREAK_TAG + "></" + dom.DEFAULT_BLOCK_TAG + ">";
        }
        this.editor.doc.setHTML(html);
        return this.editor.checkUpdate(source);
      };
      Quill2.prototype.setSelection = function(start, end, source) {
        var range;
        if (source == null) {
          source = Quill2.sources.API;
        }
        if (_.isNumber(start) && _.isNumber(end)) {
          range = new Range2(start, end);
        } else {
          range = start;
          source = end || source;
        }
        return this.editor.selection.setRange(range, source);
      };
      Quill2.prototype.updateContents = function(delta, source) {
        if (source == null) {
          source = Quill2.sources.API;
        }
        return this.editor.applyDelta(delta, source);
      };
      Quill2.prototype._buildParams = function() {
        var formats, params;
        params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (_.isObject(params[0])) {
          params.splice(0, 1, params[0].start, params[0].end);
        }
        if (_.isString(params[2])) {
          formats = {};
          formats[params[2]] = params[3];
          params.splice(2, 2, formats);
        }
        if (params[3] == null) {
          params[3] = Quill2.sources.API;
        }
        return params;
      };
      return Quill2;
    }(EventEmitter2);
    Quill.registerTheme("default", require_default());
    Quill.registerTheme("snow", require_snow());
    module.exports = Quill;
  }
});

// node_modules/quilljs/lib/modules/authorship.js
var require_authorship = __commonJS({
  "node_modules/quilljs/lib/modules/authorship.js"(exports, module) {
    var Authorship;
    var Delta;
    var Quill;
    var dom;
    var _;
    Quill = require_quill();
    _ = Quill.require("lodash");
    dom = Quill.require("dom");
    Delta = Quill.require("delta");
    Authorship = function() {
      Authorship2.DEFAULTS = {
        authorId: null,
        color: "transparent",
        enabled: false
      };
      function Authorship2(quill, options) {
        this.quill = quill;
        this.options = options;
        if (this.options.button != null) {
          this.attachButton(this.options.button);
        }
        if (this.options.enabled) {
          this.enable();
        }
        this.quill.addFormat("author", {
          "class": "author-"
        });
        if (this.options.authorId == null) {
          return;
        }
        this.quill.on(this.quill.constructor.events.PRE_EVENT, /* @__PURE__ */ function(_this) {
          return function(eventName, delta, origin) {
            var authorDelta, authorFormat;
            if (eventName === _this.quill.constructor.events.TEXT_CHANGE && origin === "user") {
              authorDelta = new Delta();
              authorFormat = {
                author: _this.options.authorId
              };
              _.each(delta.ops, function(op) {
                if (op["delete"] != null) {
                  return;
                }
                if (op.insert != null || op.retain != null && op.attributes != null) {
                  op.attributes || (op.attributes = {});
                  op.attributes.author = _this.options.authorId;
                  return authorDelta.retain(op.retain || op.insert.length || 1, authorFormat);
                } else {
                  return authorDelta.retain(op.retain);
                }
              });
              return _this.quill.updateContents(authorDelta, Quill.sources.SILENT);
            }
          };
        }(this));
        this.addAuthor(this.options.authorId, this.options.color);
      }
      Authorship2.prototype.addAuthor = function(id, color) {
        var styles;
        styles = {};
        styles[".authorship .author-" + id] = {
          "background-color": "" + color
        };
        return this.quill.addStyles(styles);
      };
      Authorship2.prototype.attachButton = function(button) {
        var $button;
        $button = dom(button);
        return $button.on("click", /* @__PURE__ */ function(_this) {
          return function() {
            $button.toggleClass("ql-on");
            return _this.enable($dom.hasClass("ql-on"));
          };
        }(this));
      };
      Authorship2.prototype.enable = function(enabled) {
        if (enabled == null) {
          enabled = true;
        }
        return dom(this.quill.root).toggleClass("authorship", enabled);
      };
      Authorship2.prototype.disable = function() {
        return this.enable(false);
      };
      return Authorship2;
    }();
    Quill.registerModule("authorship", Authorship);
    module.exports = Authorship;
  }
});

// node_modules/quilljs/lib/modules/tooltip.js
var require_tooltip = __commonJS({
  "node_modules/quilljs/lib/modules/tooltip.js"(exports, module) {
    var Normalizer;
    var Quill;
    var Tooltip;
    var dom;
    var _;
    Quill = require_quill();
    Normalizer = require_normalizer();
    _ = Quill.require("lodash");
    dom = Quill.require("dom");
    Tooltip = function() {
      Tooltip2.DEFAULTS = {
        offset: 10,
        styles: {
          ".tooltip": {
            "background-color": "#fff",
            "border": "1px solid #000",
            "top": "0px",
            "white-space": "nowrap",
            "z-index": "2000"
          },
          ".tooltip a": {
            "cursor": "pointer",
            "text-decoration": "none"
          }
        },
        template: ""
      };
      Tooltip2.HIDE_MARGIN = "-10000px";
      function Tooltip2(quill, options) {
        this.quill = quill;
        this.options = options;
        this.quill.addStyles(this.options.styles);
        this.container = this.quill.addContainer("tooltip");
        this.container.innerHTML = Normalizer.stripWhitespace(this.options.template);
        this.container.style.position = "absolute";
        dom(this.quill.root).on("focus", _.bind(this.hide, this));
        this.hide();
        this.quill.on(this.quill.constructor.events.TEXT_CHANGE, /* @__PURE__ */ function(_this) {
          return function(delta, source) {
            if (source === "user" && _this.container.style.left !== Tooltip2.HIDE_MARGIN) {
              _this.range = null;
              return _this.hide();
            }
          };
        }(this));
      }
      Tooltip2.prototype.initTextbox = function(textbox, enterCallback, escapeCallback) {
        return dom(textbox).on("keyup", /* @__PURE__ */ function(_this) {
          return function(event) {
            switch (event.which) {
              case dom.KEYS.ENTER:
                return enterCallback.call(_this);
              case dom.KEYS.ESCAPE:
                return escapeCallback.call(_this);
              default:
                return true;
            }
          };
        }(this));
      };
      Tooltip2.prototype.hide = function() {
        this.container.style.left = Tooltip2.HIDE_MARGIN;
        if (this.range) {
          this.quill.setSelection(this.range);
        }
        return this.range = null;
      };
      Tooltip2.prototype.show = function(reference) {
        var left, top, win, _ref, _ref1;
        this.range = this.quill.getSelection();
        _ref = this._position(reference), left = _ref[0], top = _ref[1];
        _ref1 = this._limit(left, top), left = _ref1[0], top = _ref1[1];
        win = dom(this.quill.root).window();
        left += win.pageXOffset;
        top += win.pageYOffset;
        this.container.style.left = "" + left + "px";
        this.container.style.top = "" + top + "px";
        return this.container.focus();
      };
      Tooltip2.prototype._getBounds = function() {
        var bounds, scrollX, scrollY, win;
        bounds = this.quill.root.getBoundingClientRect();
        win = dom(this.quill.root).window();
        scrollX = win.pageXOffset;
        scrollY = win.pageYOffset;
        return {
          left: bounds.left + scrollX,
          right: bounds.right + scrollX,
          top: bounds.top + scrollY,
          bottom: bounds.bottom + scrollY,
          width: bounds.width,
          height: bounds.height
        };
      };
      Tooltip2.prototype._limit = function(left, top) {
        var editorRect, toolbarRect;
        editorRect = this._getBounds();
        toolbarRect = this.container.getBoundingClientRect();
        left = Math.min(editorRect.right - toolbarRect.width, left);
        left = Math.max(editorRect.left, left);
        top = Math.min(editorRect.bottom - toolbarRect.height, top);
        top = Math.max(editorRect.top, top);
        return [left, top];
      };
      Tooltip2.prototype._position = function(reference) {
        var editorRect, left, referenceBounds, toolbarRect, top;
        toolbarRect = this.container.getBoundingClientRect();
        editorRect = this._getBounds();
        if (reference != null) {
          referenceBounds = reference.getBoundingClientRect();
          left = referenceBounds.left + referenceBounds.width / 2 - toolbarRect.width / 2;
          top = referenceBounds.top + referenceBounds.height + this.options.offset;
          if (top + toolbarRect.height > editorRect.bottom) {
            top = referenceBounds.top - toolbarRect.height - this.options.offset;
          }
        } else {
          left = editorRect.left + editorRect.width / 2 - toolbarRect.width / 2;
          top = editorRect.top + editorRect.height / 2 - toolbarRect.height / 2;
        }
        return [left, top];
      };
      return Tooltip2;
    }();
    Quill.registerModule("tooltip", Tooltip);
    module.exports = Tooltip;
  }
});

// node_modules/quilljs/lib/modules/image-tooltip.js
var require_image_tooltip = __commonJS({
  "node_modules/quilljs/lib/modules/image-tooltip.js"(exports, module) {
    var Delta;
    var ImageTooltip;
    var Quill;
    var Tooltip;
    var dom;
    var _;
    var __hasProp = {}.hasOwnProperty;
    var __extends = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    Quill = require_quill();
    Tooltip = require_tooltip();
    _ = Quill.require("lodash");
    dom = Quill.require("dom");
    Delta = Quill.require("delta");
    ImageTooltip = function(_super) {
      __extends(ImageTooltip2, _super);
      ImageTooltip2.DEFAULTS = {
        styles: {
          ".image-tooltip-container": {
            "margin": "25px",
            "padding": "10px",
            "width": "300px"
          },
          ".image-tooltip-container:after": {
            "clear": "both",
            "content": '""',
            "display": "table"
          },
          ".image-tooltip-container .preview": {
            "margin": "10px 0px",
            "position": "relative",
            "border": "1px dashed #000",
            "height": "200px"
          },
          ".image-tooltip-container .preview span": {
            "display": "inline-block",
            "position": "absolute",
            "text-align": "center",
            "top": "40%",
            "width": "100%"
          },
          ".image-tooltip-container img": {
            "bottom": "0",
            "left": "0",
            "margin": "auto",
            "max-height": "100%",
            "max-width": "100%",
            "position": "absolute",
            "right": "0",
            "top": "0"
          },
          ".image-tooltip-container .input": {
            "box-sizing": "border-box",
            "width": "100%"
          },
          ".image-tooltip-container a": {
            "border": "1px solid black",
            "box-sizing": "border-box",
            "display": "inline-block",
            "float": "left",
            "padding": "5px",
            "text-align": "center",
            "width": "50%"
          }
        },
        template: '<input class="input" type="textbox"> <div class="preview"> <span>Preview</span> </div> <a href="javascript:;" class="cancel">Cancel</a> <a href="javascript:;" class="insert">Insert</a>'
      };
      function ImageTooltip2(quill, options) {
        this.quill = quill;
        this.options = options;
        this.options.styles = _.defaults(this.options.styles, Tooltip.DEFAULTS.styles);
        this.options = _.defaults(this.options, Tooltip.DEFAULTS);
        ImageTooltip2.__super__.constructor.call(this, this.quill, this.options);
        this.preview = this.container.querySelector(".preview");
        this.textbox = this.container.querySelector(".input");
        dom(this.container).addClass("image-tooltip-container");
        this.initListeners();
      }
      ImageTooltip2.prototype.initListeners = function() {
        dom(this.container.querySelector(".insert")).on("click", _.bind(this.insertImage, this));
        dom(this.container.querySelector(".cancel")).on("click", _.bind(this.hide, this));
        dom(this.textbox).on("input", _.bind(this._preview, this));
        this.initTextbox(this.textbox, this.insertImage, this.hide);
        return this.quill.onModuleLoad("toolbar", /* @__PURE__ */ function(_this) {
          return function(toolbar) {
            return toolbar.initFormat("image", _.bind(_this._onToolbar, _this));
          };
        }(this));
      };
      ImageTooltip2.prototype.insertImage = function() {
        var index, url;
        url = this._normalizeURL(this.textbox.value);
        if (this.range == null) {
          this.range = new Range(0, 0);
        }
        if (this.range) {
          this.preview.innerHTML = "<span>Preview</span>";
          this.textbox.value = "";
          index = this.range.end;
          this.quill.insertEmbed(index, "image", url, "user");
          this.quill.setSelection(index + 1, index + 1);
        }
        return this.hide();
      };
      ImageTooltip2.prototype._onToolbar = function(range, value) {
        if (value) {
          if (!this.textbox.value) {
            this.textbox.value = "http://";
          }
          this.show();
          this.textbox.focus();
          return _.defer(/* @__PURE__ */ function(_this) {
            return function() {
              return _this.textbox.setSelectionRange(_this.textbox.value.length, _this.textbox.value.length);
            };
          }(this));
        } else {
          return this.quill.deleteText(range, "user");
        }
      };
      ImageTooltip2.prototype._preview = function() {
        var img;
        if (!this._matchImageURL(this.textbox.value)) {
          return;
        }
        if (this.preview.firstChild.tagName === "IMG") {
          return this.preview.firstChild.setAttribute("src", this.textbox.value);
        } else {
          img = this.preview.ownerDocument.createElement("img");
          img.setAttribute("src", this.textbox.value);
          return this.preview.replaceChild(img, this.preview.firstChild);
        }
      };
      ImageTooltip2.prototype._matchImageURL = function(url) {
        return /^https?:\/\/.+\.(jp?g|gif|png)$/.test(url);
      };
      ImageTooltip2.prototype._normalizeURL = function(url) {
        if (!/^https?:\/\//.test(url)) {
          url = "http://" + url;
        }
        return url;
      };
      return ImageTooltip2;
    }(Tooltip);
    Quill.registerModule("image-tooltip", ImageTooltip);
    module.exports = ImageTooltip;
  }
});

// node_modules/quilljs/lib/modules/keyboard.js
var require_keyboard = __commonJS({
  "node_modules/quilljs/lib/modules/keyboard.js"(exports, module) {
    var Delta;
    var Keyboard;
    var Quill;
    var dom;
    var _;
    Quill = require_quill();
    _ = Quill.require("lodash");
    dom = Quill.require("dom");
    Delta = Quill.require("delta");
    Keyboard = function() {
      Keyboard2.hotkeys = {
        BOLD: {
          key: "B",
          metaKey: true
        },
        INDENT: {
          key: dom.KEYS.TAB
        },
        ITALIC: {
          key: "I",
          metaKey: true
        },
        OUTDENT: {
          key: dom.KEYS.TAB,
          shiftKey: true
        },
        UNDERLINE: {
          key: "U",
          metaKey: true
        }
      };
      function Keyboard2(quill, options) {
        this.quill = quill;
        this.hotkeys = {};
        this._initListeners();
        this._initHotkeys();
        this._initDeletes();
      }
      Keyboard2.prototype.addHotkey = function(hotkeys, callback) {
        if (!_.isArray(hotkeys)) {
          hotkeys = [hotkeys];
        }
        return _.each(hotkeys, /* @__PURE__ */ function(_this) {
          return function(hotkey) {
            var which, _base;
            hotkey = _.isObject(hotkey) ? _.clone(hotkey) : {
              key: hotkey
            };
            hotkey.callback = callback;
            which = _.isNumber(hotkey.key) ? hotkey.key : hotkey.key.toUpperCase().charCodeAt(0);
            if ((_base = _this.hotkeys)[which] == null) {
              _base[which] = [];
            }
            return _this.hotkeys[which].push(hotkey);
          };
        }(this));
      };
      Keyboard2.prototype.toggleFormat = function(range, format) {
        var delta, toolbar, value;
        if (range.isCollapsed()) {
          delta = this.quill.getContents(Math.max(0, range.start - 1), range.end);
        } else {
          delta = this.quill.getContents(range);
        }
        value = delta.ops.length === 0 || !_.all(delta.ops, function(op) {
          var _ref;
          return (_ref = op.attributes) != null ? _ref[format] : void 0;
        });
        if (range.isCollapsed()) {
          this.quill.prepareFormat(format, value);
        } else {
          this.quill.formatText(range, format, value, "user");
        }
        toolbar = this.quill.getModule("toolbar");
        if (toolbar != null) {
          return toolbar.setActive(format, value);
        }
      };
      Keyboard2.prototype._initDeletes = function() {
        return this.addHotkey([dom.KEYS.DELETE, dom.KEYS.BACKSPACE], /* @__PURE__ */ function(_this) {
          return function() {
            return _this.quill.getLength() > 1;
          };
        }(this));
      };
      Keyboard2.prototype._initHotkeys = function() {
        this.addHotkey(Keyboard2.hotkeys.INDENT, /* @__PURE__ */ function(_this) {
          return function(range) {
            _this._onTab(range, false);
            return false;
          };
        }(this));
        this.addHotkey(Keyboard2.hotkeys.OUTDENT, /* @__PURE__ */ function(_this) {
          return function(range) {
            return false;
          };
        }(this));
        return _.each(["bold", "italic", "underline"], /* @__PURE__ */ function(_this) {
          return function(format) {
            return _this.addHotkey(Keyboard2.hotkeys[format.toUpperCase()], function(range) {
              _this.toggleFormat(range, format);
              return false;
            });
          };
        }(this));
      };
      Keyboard2.prototype._initListeners = function() {
        return dom(this.quill.root).on("keydown", /* @__PURE__ */ function(_this) {
          return function(event) {
            var prevent;
            prevent = false;
            _.each(_this.hotkeys[event.which], function(hotkey) {
              var metaKey;
              metaKey = dom.isMac() ? event.metaKey : event.metaKey || event.ctrlKey;
              if (!!hotkey.metaKey !== !!metaKey) {
                return;
              }
              if (!!hotkey.shiftKey !== !!event.shiftKey) {
                return;
              }
              if (!!hotkey.altKey !== !!event.altKey) {
                return;
              }
              prevent = hotkey.callback(_this.quill.getSelection()) === false || prevent;
              return true;
            });
            return !prevent;
          };
        }(this));
      };
      Keyboard2.prototype._onTab = function(range, shift) {
        var delta;
        if (shift == null) {
          shift = false;
        }
        delta = new Delta().retain(range.start).insert("	")["delete"](range.end - range.start).retain(this.quill.getLength() - range.end);
        this.quill.updateContents(delta);
        return this.quill.setSelection(range.start + 1, range.start + 1);
      };
      return Keyboard2;
    }();
    Quill.registerModule("keyboard", Keyboard);
    module.exports = Keyboard;
  }
});

// node_modules/quilljs/lib/modules/link-tooltip.js
var require_link_tooltip = __commonJS({
  "node_modules/quilljs/lib/modules/link-tooltip.js"(exports, module) {
    var LinkTooltip;
    var Quill;
    var Tooltip;
    var dom;
    var _;
    var __hasProp = {}.hasOwnProperty;
    var __extends = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    Quill = require_quill();
    Tooltip = require_tooltip();
    _ = Quill.require("lodash");
    dom = Quill.require("dom");
    LinkTooltip = function(_super) {
      __extends(LinkTooltip2, _super);
      LinkTooltip2.DEFAULTS = {
        maxLength: 50,
        styles: {
          ".link-tooltip-container": {
            "padding": "5px 10px"
          },
          ".link-tooltip-container input.input": {
            "width": "170px"
          },
          ".link-tooltip-container input.input, .link-tooltip-container a.done, .link-tooltip-container.editing a.url, .link-tooltip-container.editing a.change": {
            "display": "none"
          },
          ".link-tooltip-container.editing input.input, .link-tooltip-container.editing a.done": {
            "display": "inline-block"
          }
        },
        template: '<span class="title">Visit URL:&nbsp;</span> <a href="#" class="url" target="_blank" href="about:blank"></a> <input class="input" type="text"> <span>&nbsp;&#45;&nbsp;</span> <a href="javascript:;" class="change">Change</a> <a href="javascript:;" class="done">Done</a>'
      };
      function LinkTooltip2(quill, options) {
        this.quill = quill;
        this.options = options;
        this.options.styles = _.defaults(this.options.styles, Tooltip.DEFAULTS.styles);
        this.options = _.defaults(this.options, Tooltip.DEFAULTS);
        LinkTooltip2.__super__.constructor.call(this, this.quill, this.options);
        dom(this.container).addClass("link-tooltip-container");
        this.textbox = this.container.querySelector(".input");
        this.link = this.container.querySelector(".url");
        this.initListeners();
      }
      LinkTooltip2.prototype.initListeners = function() {
        this.quill.on(this.quill.constructor.events.SELECTION_CHANGE, /* @__PURE__ */ function(_this) {
          return function(range) {
            var anchor;
            if (!(range != null && range.isCollapsed())) {
              return;
            }
            anchor = _this._findAnchor(range);
            if (anchor) {
              _this.setMode(anchor.href, false);
              return _this.show(anchor);
            } else {
              _this.range = null;
              return _this.hide();
            }
          };
        }(this));
        dom(this.container.querySelector(".done")).on("click", _.bind(this.saveLink, this));
        dom(this.container.querySelector(".change")).on("click", /* @__PURE__ */ function(_this) {
          return function() {
            return _this.setMode(_this.link.href, true);
          };
        }(this));
        this.initTextbox(this.textbox, this.saveLink, this.hide);
        return this.quill.onModuleLoad("toolbar", /* @__PURE__ */ function(_this) {
          return function(toolbar) {
            return toolbar.initFormat("link", _.bind(_this._onToolbar, _this));
          };
        }(this));
      };
      LinkTooltip2.prototype.saveLink = function() {
        var anchor, url;
        url = this._normalizeURL(this.textbox.value);
        if (this.range != null) {
          if (this.range.isCollapsed()) {
            anchor = this._findAnchor(this.range);
            if (anchor != null) {
              anchor.href = url;
            }
          } else {
            this.quill.formatText(this.range, "link", url, "user");
          }
        }
        return this.setMode(url, false);
      };
      LinkTooltip2.prototype.setMode = function(url, edit) {
        var text;
        if (edit == null) {
          edit = false;
        }
        if (edit) {
          this.textbox.value = url;
          _.defer(/* @__PURE__ */ function(_this) {
            return function() {
              _this.textbox.focus();
              return _this.textbox.setSelectionRange(url.length, url.length);
            };
          }(this));
        } else {
          this.link.href = url;
          text = url.length > this.options.maxLength ? url.slice(0, this.options.maxLength) + "..." : url;
          dom(this.link).text(text);
        }
        return dom(this.container).toggleClass("editing", edit);
      };
      LinkTooltip2.prototype._findAnchor = function(range) {
        var leaf, node, offset, _ref;
        _ref = this.quill.editor.doc.findLeafAt(range.start, true), leaf = _ref[0], offset = _ref[1];
        if (leaf != null) {
          node = leaf.node;
        }
        while (node != null) {
          if (node.tagName === "A") {
            return node;
          }
          node = node.parentNode;
        }
        return null;
      };
      LinkTooltip2.prototype._onToolbar = function(range, value) {
        var nativeRange;
        if (!(range && !range.isCollapsed())) {
          return;
        }
        if (value) {
          this.setMode(this._suggestURL(range), true);
          nativeRange = this.quill.editor.selection._getNativeRange();
          return this.show(nativeRange);
        } else {
          return this.quill.formatText(range, "link", false, "user");
        }
      };
      LinkTooltip2.prototype._normalizeURL = function(url) {
        if (!/^(https?:\/\/|mailto:)/.test(url)) {
          url = "http://" + url;
        }
        return url;
      };
      LinkTooltip2.prototype._suggestURL = function(range) {
        var text;
        text = this.quill.getText(range);
        return this._normalizeURL(text);
      };
      return LinkTooltip2;
    }(Tooltip);
    Quill.registerModule("link-tooltip", LinkTooltip);
    module.exports = LinkTooltip;
  }
});

// node_modules/quilljs/lib/modules/multi-cursor.js
var require_multi_cursor = __commonJS({
  "node_modules/quilljs/lib/modules/multi-cursor.js"(exports, module) {
    var EventEmitter2;
    var MultiCursor;
    var Quill;
    var dom;
    var _;
    var __hasProp = {}.hasOwnProperty;
    var __extends = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    Quill = require_quill();
    EventEmitter2 = require_eventemitter2().EventEmitter2;
    _ = Quill.require("lodash");
    dom = Quill.require("dom");
    MultiCursor = function(_super) {
      __extends(MultiCursor2, _super);
      MultiCursor2.DEFAULTS = {
        template: '<span class="cursor-flag"> <span class="cursor-name"></span> </span> <span class="cursor-caret"></span>',
        timeout: 2500
      };
      MultiCursor2.events = {
        CURSOR_ADDED: "cursor-addded",
        CURSOR_MOVED: "cursor-moved",
        CURSOR_REMOVED: "cursor-removed"
      };
      function MultiCursor2(quill, options) {
        this.quill = quill;
        this.options = options;
        this.cursors = {};
        this.container = this.quill.addContainer("cursor-container", true);
        this.quill.addStyles({
          ".cursor-container": {
            "position": "absolute",
            "left": "0",
            "top": "0",
            "z-index": "1000"
          },
          ".cursor": {
            "margin-left": "-1px",
            "position": "absolute"
          },
          ".cursor-flag": {
            "bottom": "100%",
            "position": "absolute",
            "white-space": "nowrap"
          },
          ".cursor-name": {
            "display": "inline-block",
            "color": "white",
            "padding": "2px 8px"
          },
          ".cursor-caret": {
            "height": "100%",
            "position": "absolute",
            "width": "2px"
          },
          ".cursor.hidden .cursor-flag": {
            "display": "none"
          },
          ".cursor.top > .cursor-flag": {
            "bottom": "auto",
            "top": "100%"
          },
          ".cursor.right > .cursor-flag": {
            "right": "-2px"
          }
        });
        this.quill.on(this.quill.constructor.events.TEXT_CHANGE, _.bind(this._applyDelta, this));
      }
      MultiCursor2.prototype.clearCursors = function() {
        _.each(_.keys(this.cursors), _.bind(this.removeCursor, this));
        return this.cursors = {};
      };
      MultiCursor2.prototype.moveCursor = function(userId, index) {
        var cursor;
        cursor = this.cursors[userId];
        cursor.index = index;
        dom(cursor.elem).removeClass("hidden");
        clearTimeout(cursor.timer);
        cursor.timer = setTimeout(/* @__PURE__ */ function(_this) {
          return function() {
            dom(cursor.elem).addClass("hidden");
            return cursor.timer = null;
          };
        }(this), this.options.timeout);
        this._updateCursor(cursor);
        return cursor;
      };
      MultiCursor2.prototype.removeCursor = function(userId) {
        var cursor;
        cursor = this.cursors[userId];
        this.emit(MultiCursor2.events.CURSOR_REMOVED, cursor);
        if (cursor != null) {
          cursor.elem.parentNode.removeChild(cursor.elem);
        }
        return delete this.cursors[userId];
      };
      MultiCursor2.prototype.setCursor = function(userId, index, name, color) {
        var cursor;
        if (this.cursors[userId] == null) {
          this.cursors[userId] = cursor = {
            userId,
            index,
            color,
            elem: this._buildCursor(name, color)
          };
          this.emit(MultiCursor2.events.CURSOR_ADDED, cursor);
        }
        _.defer(/* @__PURE__ */ function(_this) {
          return function() {
            return _this.moveCursor(userId, index);
          };
        }(this));
        return this.cursors[userId];
      };
      MultiCursor2.prototype.shiftCursors = function(index, length, authorId) {
        if (authorId == null) {
          authorId = null;
        }
        return _.each(this.cursors, /* @__PURE__ */ function(_this) {
          return function(cursor, id) {
            if (!(cursor && (cursor.index > index || cursor.userId === authorId))) {
              return;
            }
            return cursor.index += Math.max(length, index - cursor.index);
          };
        }(this));
      };
      MultiCursor2.prototype.update = function() {
        return _.each(this.cursors, /* @__PURE__ */ function(_this) {
          return function(cursor, id) {
            if (cursor == null) {
              return;
            }
            _this._updateCursor(cursor);
            return true;
          };
        }(this));
      };
      MultiCursor2.prototype._applyDelta = function(delta) {
        var index;
        index = 0;
        _.each(delta.ops, /* @__PURE__ */ function(_this) {
          return function(op) {
            var length, _ref;
            length = 0;
            if (op.insert != null) {
              length = op.insert.length || 1;
              _this.shiftCursors(index, length, (_ref = op.attributes) != null ? _ref["author"] : void 0);
            } else if (op["delete"] != null) {
              _this.shiftCursors(index, -1 * op["delete"], null);
            } else if (op.retain != null) {
              _this.shiftCursors(index, 0, null);
              length = op.retain;
            }
            return index += length;
          };
        }(this));
        return this.update();
      };
      MultiCursor2.prototype._buildCursor = function(name, color) {
        var cursor, cursorCaret, cursorFlag, cursorName;
        cursor = this.container.ownerDocument.createElement("span");
        dom(cursor).addClass("cursor");
        cursor.innerHTML = this.options.template;
        cursorFlag = cursor.querySelector(".cursor-flag");
        cursorName = cursor.querySelector(".cursor-name");
        dom(cursorName).text(name);
        cursorCaret = cursor.querySelector(".cursor-caret");
        cursorCaret.style.backgroundColor = cursorName.style.backgroundColor = color;
        this.container.appendChild(cursor);
        return cursor;
      };
      MultiCursor2.prototype._moveCursor = function(cursor, reference, side) {
        var bounds, flag, win;
        if (side == null) {
          side = "left";
        }
        win = dom(reference).window();
        bounds = reference.getBoundingClientRect();
        cursor.elem.style.top = bounds.top + win.pageYOffset + "px";
        cursor.elem.style.left = bounds[side] + "px";
        cursor.elem.style.height = bounds.height + "px";
        flag = cursor.elem.querySelector(".cursor-flag");
        dom(cursor.elem).toggleClass("top", parseInt(cursor.elem.style.top) <= flag.offsetHeight).toggleClass("left", parseInt(cursor.elem.style.left) <= flag.offsetWidth).toggleClass("right", this.quill.root.offsetWidth - parseInt(cursor.elem.style.left) <= flag.offsetWidth);
        return this.emit(MultiCursor2.events.CURSOR_MOVED, cursor);
      };
      MultiCursor2.prototype._updateCursor = function(cursor) {
        var didSplit, guide, leaf, leftNode, offset, rightNode, _ref, _ref1;
        this.quill.editor.checkUpdate();
        _ref = this.quill.editor.doc.findLeafAt(cursor.index, true), leaf = _ref[0], offset = _ref[1];
        guide = this.container.ownerDocument.createElement("span");
        if (leaf != null) {
          _ref1 = dom(leaf.node).split(offset), leftNode = _ref1[0], rightNode = _ref1[1], didSplit = _ref1[2];
          dom(guide).text(dom.ZERO_WIDTH_NOBREAK_SPACE);
          leaf.node.parentNode.insertBefore(guide, rightNode);
        } else {
          dom(guide).text(dom.NOBREAK_SPACE);
          this.quill.root.appendChild(guide);
        }
        this._moveCursor(cursor, guide);
        dom(guide).remove();
        if (didSplit) {
          dom(leaf.node.parentNode).normalize();
        }
        return this.quill.editor.selection.update(Quill.sources.SILENT);
      };
      return MultiCursor2;
    }(EventEmitter2);
    Quill.registerModule("multi-cursor", MultiCursor);
    module.exports = MultiCursor;
  }
});

// node_modules/quilljs/lib/modules/paste-manager.js
var require_paste_manager = __commonJS({
  "node_modules/quilljs/lib/modules/paste-manager.js"(exports, module) {
    var Delta;
    var Document;
    var PasteManager;
    var Quill;
    var dom;
    var _;
    Quill = require_quill();
    Document = require_document();
    _ = Quill.require("lodash");
    dom = Quill.require("dom");
    Delta = Quill.require("delta");
    PasteManager = function() {
      function PasteManager2(quill, options) {
        this.quill = quill;
        this.options = options;
        this.container = this.quill.addContainer("paste-container");
        this.container.setAttribute("contenteditable", true);
        this.quill.addStyles({
          ".paste-container": {
            "left": "-10000px",
            "position": "absolute",
            "top": "50%"
          }
        });
        dom(this.quill.root).on("paste", _.bind(this._paste, this));
      }
      PasteManager2.prototype._paste = function() {
        var iframe, iframeScrollY, oldDocLength, range, windowScrollX, windowScrollY;
        oldDocLength = this.quill.getLength();
        range = this.quill.getSelection();
        if (range == null) {
          return;
        }
        this.container.innerHTML = "";
        iframe = dom(this.quill.root).window();
        iframeScrollY = iframe.scrollY;
        windowScrollX = window.scrollX;
        windowScrollY = window.scrollY;
        this.container.focus();
        return _.defer(/* @__PURE__ */ function(_this) {
          return function() {
            var delta, doc, lengthAdded, line, lineBottom, offset, _ref;
            doc = new Document(_this.container, _this.quill.options);
            delta = doc.toDelta();
            lengthAdded = delta.length() - 1;
            delta.compose(new Delta().retain(lengthAdded)["delete"](1));
            if (range.start > 0) {
              delta.ops.unshift({
                retain: range.start
              });
            }
            delta["delete"](range.end - range.start);
            _this.quill.updateContents(delta, "user");
            _this.quill.setSelection(range.start + lengthAdded, range.start + lengthAdded);
            _ref = _this.quill.editor.doc.findLineAt(range.start + lengthAdded), line = _ref[0], offset = _ref[1];
            lineBottom = line.node.offsetTop + line.node.offsetHeight;
            if (lineBottom > iframeScrollY + _this.quill.root.offsetHeight) {
              iframeScrollY = line.node.offsetTop - _this.quill.root.offsetHeight / 2;
            }
            iframe.scrollTo(0, iframeScrollY);
            return window.scrollTo(windowScrollX, windowScrollY);
          };
        }(this));
      };
      return PasteManager2;
    }();
    Quill.registerModule("paste-manager", PasteManager);
    module.exports = PasteManager;
  }
});

// node_modules/quilljs/lib/modules/toolbar.js
var require_toolbar = __commonJS({
  "node_modules/quilljs/lib/modules/toolbar.js"(exports, module) {
    var Quill;
    var Toolbar;
    var dom;
    var _;
    Quill = require_quill();
    _ = Quill.require("lodash");
    dom = Quill.require("dom");
    Toolbar = function() {
      Toolbar2.DEFAULTS = {
        container: null
      };
      Toolbar2.formats = {
        LINE: {
          "align": "align",
          "bullet": "bullet",
          "list": "list"
        },
        SELECT: {
          "align": "align",
          "background": "background",
          "color": "color",
          "font": "font",
          "size": "size"
        },
        TOGGLE: {
          "bold": "bold",
          "bullet": "bullet",
          "image": "image",
          "italic": "italic",
          "link": "link",
          "list": "list",
          "strike": "strike",
          "underline": "underline"
        },
        TOOLTIP: {
          "image": "image",
          "link": "link"
        }
      };
      function Toolbar2(quill, options) {
        this.quill = quill;
        this.options = options;
        if (this.options.container == null) {
          throw new Error("container required for toolbar", this.options);
        }
        this.container = _.isString(this.options.container) ? document.querySelector(this.options.container) : this.options.container;
        this.inputs = {};
        this.preventUpdate = false;
        this.triggering = false;
        _.each(this.quill.options.formats, /* @__PURE__ */ function(_this) {
          return function(format) {
            if (Toolbar2.formats.TOOLTIP[format] != null) {
              return;
            }
            return _this.initFormat(format, function(range, value) {
              if (_this.triggering) {
                return;
              }
              if (range.isCollapsed()) {
                _this.quill.prepareFormat(format, value);
              } else if (Toolbar2.formats.LINE[format] != null) {
                _this.quill.formatLine(range, format, value, "user");
              } else {
                _this.quill.formatText(range, format, value, "user");
              }
              return _.defer(function() {
                _this.updateActive(range, ["bullet", "list"]);
                return _this.setActive(format, value);
              });
            });
          };
        }(this));
        this.quill.on(this.quill.constructor.events.SELECTION_CHANGE, /* @__PURE__ */ function(_this) {
          return function(range) {
            if (range != null) {
              return _this.updateActive(range);
            }
          };
        }(this));
        this.quill.onModuleLoad("keyboard", /* @__PURE__ */ function(_this) {
          return function(keyboard) {
            return keyboard.addHotkey([dom.KEYS.BACKSPACE, dom.KEYS.DELETE, dom.KEYS.ENTER], function() {
              return _.defer(_.bind(_this.updateActive, _this));
            });
          };
        }(this));
        dom(this.container).addClass("ql-toolbar-container");
        if (dom.isIOS()) {
          dom(this.container).addClass("ios");
        }
        if (dom.isIE(11)) {
          dom(this.container).on("mousedown", /* @__PURE__ */ function(_this) {
            return function() {
              return false;
            };
          }(this));
        }
      }
      Toolbar2.prototype.initFormat = function(format, callback) {
        var eventName, input, selector;
        selector = ".ql-" + format;
        if (Toolbar2.formats.SELECT[format] != null) {
          selector = "select" + selector;
          eventName = "change";
        } else {
          eventName = "click";
        }
        input = this.container.querySelector(selector);
        if (input == null) {
          return;
        }
        this.inputs[format] = input;
        return dom(input).on(eventName, /* @__PURE__ */ function(_this) {
          return function() {
            var range, value;
            value = eventName === "change" ? dom(input).value() : !dom(input).hasClass("ql-active");
            _this.preventUpdate = true;
            _this.quill.focus();
            range = _this.quill.getSelection();
            if (range != null) {
              callback(range, value);
            }
            _this.preventUpdate = false;
            return true;
          };
        }(this));
      };
      Toolbar2.prototype.setActive = function(format, value) {
        var $input, input, selectValue, _ref;
        input = this.inputs[format];
        if (input == null) {
          return;
        }
        $input = dom(input);
        if (input.tagName === "SELECT") {
          this.triggering = true;
          selectValue = $input.value(input);
          if (value == null) {
            value = (_ref = $input["default"]()) != null ? _ref.value : void 0;
          }
          if (_.isArray(value)) {
            value = "";
          }
          if (value !== selectValue) {
            if (value != null) {
              $input.option(value, false);
            } else {
              $input.reset(false);
            }
          }
          return this.triggering = false;
        } else {
          return $input.toggleClass("ql-active", value || false);
        }
      };
      Toolbar2.prototype.updateActive = function(range, formats) {
        var activeFormats;
        if (formats == null) {
          formats = null;
        }
        range || (range = this.quill.getSelection());
        if (!(range != null && !this.preventUpdate)) {
          return;
        }
        activeFormats = this._getActive(range);
        return _.each(this.inputs, /* @__PURE__ */ function(_this) {
          return function(input, format) {
            if (!_.isArray(formats) || formats.indexOf(format) > -1) {
              _this.setActive(format, activeFormats[format]);
            }
            return true;
          };
        }(this));
      };
      Toolbar2.prototype._getActive = function(range) {
        var leafFormats, lineFormats;
        leafFormats = this._getLeafActive(range);
        lineFormats = this._getLineActive(range);
        return _.defaults({}, leafFormats, lineFormats);
      };
      Toolbar2.prototype._getLeafActive = function(range) {
        var contents, formatsArr, line, offset, _ref;
        if (range.isCollapsed()) {
          _ref = this.quill.editor.doc.findLineAt(range.start), line = _ref[0], offset = _ref[1];
          if (offset === 0) {
            contents = this.quill.getContents(range.start, range.end + 1);
          } else {
            contents = this.quill.getContents(range.start - 1, range.end);
          }
        } else {
          contents = this.quill.getContents(range);
        }
        formatsArr = _.map(contents.ops, "attributes");
        return this._intersectFormats(formatsArr);
      };
      Toolbar2.prototype._getLineActive = function(range) {
        var firstLine, formatsArr, lastLine, offset, _ref, _ref1;
        formatsArr = [];
        _ref = this.quill.editor.doc.findLineAt(range.start), firstLine = _ref[0], offset = _ref[1];
        _ref1 = this.quill.editor.doc.findLineAt(range.end), lastLine = _ref1[0], offset = _ref1[1];
        if (lastLine != null && lastLine === firstLine) {
          lastLine = lastLine.next;
        }
        while (firstLine != null && firstLine !== lastLine) {
          formatsArr.push(_.clone(firstLine.formats));
          firstLine = firstLine.next;
        }
        return this._intersectFormats(formatsArr);
      };
      Toolbar2.prototype._intersectFormats = function(formatsArr) {
        return _.reduce(formatsArr.slice(1), function(activeFormats, formats) {
          var activeKeys, added, formatKeys, intersection, missing;
          activeKeys = _.keys(activeFormats);
          formatKeys = _.keys(formats);
          intersection = _.intersection(activeKeys, formatKeys);
          missing = _.difference(activeKeys, formatKeys);
          added = _.difference(formatKeys, activeKeys);
          _.each(intersection, function(name) {
            if (Toolbar2.formats.SELECT[name] != null) {
              if (_.isArray(activeFormats[name])) {
                if (_.indexOf(activeFormats[name], formats[name]) < 0) {
                  return activeFormats[name].push(formats[name]);
                }
              } else if (activeFormats[name] !== formats[name]) {
                return activeFormats[name] = [activeFormats[name], formats[name]];
              }
            }
          });
          _.each(missing, function(name) {
            if (Toolbar2.formats.TOGGLE[name] != null) {
              return delete activeFormats[name];
            } else if (Toolbar2.formats.SELECT[name] != null && !_.isArray(activeFormats[name])) {
              return activeFormats[name] = [activeFormats[name]];
            }
          });
          _.each(added, function(name) {
            if (Toolbar2.formats.SELECT[name] != null) {
              return activeFormats[name] = [formats[name]];
            }
          });
          return activeFormats;
        }, formatsArr[0] || {});
      };
      return Toolbar2;
    }();
    Quill.registerModule("toolbar", Toolbar);
    module.exports = Toolbar;
  }
});

// node_modules/quilljs/lib/modules/undo-manager.js
var require_undo_manager = __commonJS({
  "node_modules/quilljs/lib/modules/undo-manager.js"(exports, module) {
    var Delta;
    var Quill;
    var UndoManager;
    var _;
    Quill = require_quill();
    _ = Quill.require("lodash");
    Delta = Quill.require("delta");
    UndoManager = function() {
      UndoManager2.DEFAULTS = {
        delay: 1e3,
        maxStack: 100
      };
      UndoManager2.hotkeys = {
        UNDO: {
          key: "Z",
          metaKey: true
        },
        REDO: {
          key: "Z",
          metaKey: true,
          shiftKey: true
        }
      };
      function UndoManager2(quill, options) {
        this.quill = quill;
        this.options = options != null ? options : {};
        this.lastRecorded = 0;
        this.emittedDelta = null;
        this.clear();
        this.initListeners();
      }
      UndoManager2.prototype.initListeners = function() {
        this.quill.onModuleLoad("keyboard", /* @__PURE__ */ function(_this) {
          return function(keyboard) {
            keyboard.addHotkey(UndoManager2.hotkeys.UNDO, function() {
              _this.undo();
              return false;
            });
            return keyboard.addHotkey(UndoManager2.hotkeys.REDO, function() {
              _this.redo();
              return false;
            });
          };
        }(this));
        return this.quill.on(this.quill.constructor.events.TEXT_CHANGE, /* @__PURE__ */ function(_this) {
          return function(delta, origin) {
            if (_.isEqual(delta, _this.emittedDelta)) {
              return;
            }
            _this.record(delta, _this.oldDelta);
            return _this.oldDelta = _this.quill.getContents();
          };
        }(this));
      };
      UndoManager2.prototype.clear = function() {
        this.stack = {
          undo: [],
          redo: []
        };
        return this.oldDelta = this.quill.getContents();
      };
      UndoManager2.prototype.record = function(changeDelta, oldDelta) {
        var change, ignored, timestamp, undoDelta;
        if (!(changeDelta.ops.length > 0)) {
          return;
        }
        this.stack.redo = [];
        try {
          undoDelta = this.quill.getContents().diff(this.oldDelta);
          timestamp = (/* @__PURE__ */ new Date()).getTime();
          if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
            change = this.stack.undo.pop();
            undoDelta = undoDelta.compose(change.undo);
            changeDelta = change.redo.compose(changeDelta);
          } else {
            this.lastRecorded = timestamp;
          }
          this.stack.undo.push({
            redo: changeDelta,
            undo: undoDelta
          });
          if (this.stack.undo.length > this.options.maxStack) {
            return this.stack.undo.unshift();
          }
        } catch (_error) {
          ignored = _error;
          return this.clear();
        }
      };
      UndoManager2.prototype.redo = function() {
        return this._change("redo", "undo");
      };
      UndoManager2.prototype.undo = function() {
        return this._change("undo", "redo");
      };
      UndoManager2.prototype._getLastChangeIndex = function(delta) {
        var index, lastIndex;
        lastIndex = 0;
        index = 0;
        delta.ops.forEach(function(op) {
          if (op.insert != null) {
            return lastIndex = Math.max(index + (op.insert.length || 1), lastIndex);
          } else if (op["delete"] != null) {
            return lastIndex = Math.max(index, lastIndex);
          } else if (op.retain != null) {
            if (op.attributes != null) {
              lastIndex = Math.max(index + op.retain, lastIndex);
            }
            return index += op.retain;
          }
        });
        return lastIndex;
      };
      UndoManager2.prototype._change = function(source, dest) {
        var change, index;
        if (this.stack[source].length > 0) {
          change = this.stack[source].pop();
          this.lastRecorded = 0;
          this.emittedDelta = change[source];
          this.quill.updateContents(change[source], "user");
          this.emittedDelta = null;
          index = this._getLastChangeIndex(change[source]);
          this.quill.setSelection(index, index);
          this.oldDelta = this.quill.getContents();
          return this.stack[dest].push(change);
        }
      };
      return UndoManager2;
    }();
    Quill.registerModule("undo-manager", UndoManager);
    module.exports = UndoManager;
  }
});

// node_modules/quilljs/lib/index.js
var require_lib = __commonJS({
  "node_modules/quilljs/lib/index.js"(exports, module) {
    require_authorship();
    require_image_tooltip();
    require_keyboard();
    require_link_tooltip();
    require_multi_cursor();
    require_paste_manager();
    require_toolbar();
    require_tooltip();
    require_undo_manager();
    module.exports = require_quill();
  }
});

// node_modules/quilljs/index.js
var require_quilljs = __commonJS({
  "node_modules/quilljs/index.js"(exports, module) {
    module.exports = require_lib();
  }
});

// node_modules/react-quill/dist/react-quill.js
var require_react_quill = __commonJS({
  "node_modules/react-quill/dist/react-quill.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory(require_react(), require_quilljs());
      else if (typeof define === "function" && define.amd)
        define(["react", "quilljs"], factory);
      else if (typeof exports === "object")
        exports["ReactQuill"] = factory(require_react(), require_quilljs());
      else
        root["ReactQuill"] = factory(root["React"], root["Quill"]);
    })(exports, function(__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
              return installedModules[moduleId].exports;
            var module2 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: false
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.loaded = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.p = "";
          return __webpack_require__(0);
        }([
          /* 0 */
          /*!**********************!*\
            !*** ./src/index.js ***!
            \**********************/
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = __webpack_require__(
              /*! ./component */
              1
            );
            module2.exports.Mixin = __webpack_require__(
              /*! ./mixin */
              2
            );
            module2.exports.Toolbar = __webpack_require__(
              /*! ./toolbar */
              3
            );
          },
          /* 1 */
          /*!**************************!*\
            !*** ./src/component.js ***!
            \**************************/
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var React = __webpack_require__(
              /*! react */
              4
            ), QuillToolbar = __webpack_require__(
              /*! ./toolbar */
              3
            ), QuillMixin = __webpack_require__(
              /*! ./mixin */
              2
            ), T = React.PropTypes;
            if (React.createFactory) {
              QuillToolbar = React.createFactory(QuillToolbar);
            }
            var QuillComponent = React.createClass({
              displayName: "Quill",
              mixins: [QuillMixin],
              propTypes: {
                id: T.string,
                className: T.string,
                value: T.string,
                defaultValue: T.string,
                readOnly: T.bool,
                toolbar: T.object,
                formats: T.array,
                styles: T.object,
                theme: T.string,
                pollInterval: T.number,
                onChange: T.func
              },
              getDefaultProps: function() {
                return {
                  className: "",
                  modules: {}
                };
              },
              /*
              Retrieve the initial value from either `value` (preferred)
              or `defaultValue` if you want an un-controlled component.
              */
              getInitialState: function() {
                return {};
              },
              /*
              Update only if we've been passed a new `value`.
              This leaves components using `defaultValue` alone.
              */
              componentWillReceiveProps: function(nextProps) {
                if ("value" in nextProps) {
                  if (nextProps.value !== this.props.value) {
                    this.setEditorContents(this.state.editor, nextProps.value);
                  }
                }
              },
              componentDidMount: function() {
                var editor = this.createEditor(
                  this.getEditorElement(),
                  this.getEditorConfig()
                );
                this.setState({ editor });
              },
              componentWillUnmount: function() {
                this.destroyEditor(this.state.editor);
              },
              shouldComponentUpdate: function(nextProps, nextState) {
                return false;
              },
              /*
              If for whatever reason we are rendering again,
              we should tear down the editor and bring it up
              again.
              */
              componentWillUpdate: function() {
                this.componentWillUnmount();
              },
              componentDidUpdate: function() {
                this.componentDidMount();
              },
              getEditorConfig: function() {
                var config = {
                  readOnly: this.props.readOnly,
                  theme: this.props.theme,
                  formats: this.props.formats,
                  styles: this.props.styles,
                  modules: this.props.modules,
                  pollInterval: this.props.pollInterval
                };
                if (!config.modules.toolbar) {
                  config.modules = JSON.parse(JSON.stringify(config.modules));
                  config.modules.toolbar = {
                    container: this.refs.toolbar.getDOMNode()
                  };
                }
                return config;
              },
              getEditorElement: function() {
                return this.refs.editor.getDOMNode();
              },
              getEditorContents: function() {
                return this.props.value || this.props.defaultValue;
              },
              getClassName: function() {
                return ["quill", this.props.className].join(" ");
              },
              /*
              Renders either the specified contents, or a default
              configuration of toolbar and contents area.
              */
              renderContents: function() {
                if (React.Children.count(this.props.children) > 0) {
                  return React.Children.only(this.props.children);
                } else {
                  return [
                    QuillToolbar({
                      key: "toolbar",
                      ref: "toolbar",
                      items: this.props.toolbar
                    }),
                    React.DOM.div({
                      key: "editor",
                      ref: "editor",
                      className: "quill-contents",
                      dangerouslySetInnerHTML: { __html: this.getEditorContents() }
                    })
                  ];
                }
              },
              render: function() {
                return React.DOM.div(
                  {
                    className: this.getClassName(),
                    onChange: this.preventDefault
                  },
                  this.renderContents()
                );
              },
              /*
              Updates the local state with the new contents,
              executes the change handler passed as props.
              */
              onEditorChange: function(value) {
                if (value !== this.state.value) {
                  if (this.props.onChange) {
                    this.props.onChange(value);
                  }
                }
              },
              /*
              Stop change events from the toolbar from
              bubbling up outside.
              */
              preventDefault: function(event) {
                event.preventDefault();
                event.stopPropagation();
              }
            });
            module2.exports = QuillComponent;
          },
          /* 2 */
          /*!**********************!*\
            !*** ./src/mixin.js ***!
            \**********************/
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var React = __webpack_require__(
              /*! react */
              4
            ), Quill = __webpack_require__(
              /*! quilljs */
              5
            ), T = React.PropTypes;
            var QuillMixin = {
              /**
              Creates an editor on the given element. The editor will
              be passed the configuration, have its events bound,
              */
              createEditor: function($el, config) {
                var editor = new Quill($el, config);
                this.hookEditor(editor);
                return editor;
              },
              hookEditor: function(editor) {
                var self = this;
                editor.on("text-change", function(delta, source) {
                  if (self.onEditorChange) {
                    self.onEditorChange(editor.getHTML(), delta, source);
                  }
                });
              },
              updateEditor: function(editor, config) {
                throw new Error("Not implemented");
              },
              destroyEditor: function(editor) {
                editor.removeAllListeners();
              },
              /*
              Replace the contents of the editor, but keep
              the previous selection hanging around so that
              the cursor won't move.
              */
              setEditorContents: function(editor, value) {
                var sel = editor.getSelection();
                editor.setHTML(value);
                editor.setSelection(sel);
              }
            };
            module2.exports = QuillMixin;
          },
          /* 3 */
          /*!************************!*\
            !*** ./src/toolbar.js ***!
            \************************/
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var React = __webpack_require__(
              /*! react */
              4
            ), T = React.PropTypes;
            var defaultItems = [
              { label: "Formats", type: "group", items: [
                { label: "Size", type: "size", items: [
                  { label: "Normal", value: "" },
                  { label: "Smaller", value: "0.8em" },
                  { label: "Larger", value: "1.4em" },
                  { label: "Huge", value: "2em" }
                ] },
                { label: "Alignment", type: "align", items: [
                  { label: "Center", value: "center" },
                  { label: "Left", value: "left" },
                  { label: "Right", value: "right" },
                  { label: "Justify", value: "justify" }
                ] }
              ] },
              { label: "Text", type: "group", items: [
                { type: "bold", label: "Bold" },
                { type: "italic", label: "Italic" },
                { type: "strike", label: "Strike" },
                { type: "underline", label: "Underline" },
                { type: "link", label: "Link" }
              ] },
              { label: "Blocks", type: "group", items: [
                { type: "bullet", label: "Bullet" },
                { type: "list", label: "List" }
              ] }
            ];
            var QuillToolbar = React.createClass({
              displayName: "Quill Toolbar",
              propTypes: {
                id: T.string,
                className: T.string,
                items: T.array
              },
              getDefaultProps: function() {
                return {
                  items: defaultItems
                };
              },
              renderGroup: function(item) {
                return React.DOM.span(
                  {
                    key: item.label,
                    className: "ql-format-group"
                  },
                  item.items.map(this.renderItem)
                );
              },
              renderChoiceItem: function(item) {
                return React.DOM.option(
                  {
                    key: item.label || item.value,
                    value: item.value
                  },
                  item.label
                );
              },
              renderChoices: function(item) {
                return React.DOM.select(
                  {
                    key: item.label,
                    className: "ql-" + item.type
                  },
                  item.items.map(this.renderChoiceItem)
                );
              },
              renderAction: function(item) {
                return React.DOM.span(
                  {
                    key: item.label || item.value,
                    className: "ql-format-button ql-" + item.type,
                    title: item.label
                  }
                );
              },
              renderItem: function(item) {
                var mapping = {
                  "group": this.renderGroup,
                  "align": this.renderChoices,
                  "size": this.renderChoices,
                  "action": this.renderAction
                };
                var renderer = mapping[item.type] || mapping.action;
                return renderer(item);
              },
              getClassName: function() {
                return "quill-toolbar " + (this.props.className || "");
              },
              render: function() {
                return React.DOM.div(
                  {
                    className: this.getClassName()
                  },
                  this.props.items.map(this.renderItem)
                );
              }
            });
            module2.exports = QuillToolbar;
          },
          /* 4 */
          /*!**************************************************************************************!*\
            !*** external {"commonjs":"react","commonjs2":"react","amd":"react","root":"React"} ***!
            \**************************************************************************************/
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = __WEBPACK_EXTERNAL_MODULE_4__;
          },
          /* 5 */
          /*!********************************************************************************************!*\
            !*** external {"commonjs":"quilljs","commonjs2":"quilljs","amd":"quilljs","root":"Quill"} ***!
            \********************************************************************************************/
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = __WEBPACK_EXTERNAL_MODULE_5__;
          }
          /******/
        ])
      );
    });
  }
});
export default require_react_quill();
/*! Bundled license information:

lodash/dist/lodash.js:
  (**
   * @license
   * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
   * Build: `lodash modern -o ./dist/lodash.js`
   * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
   * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
   * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   * Available under MIT license <https://lodash.com/license>
   *)

eventemitter2/lib/eventemitter2.js:
  (*!
   * EventEmitter2
   * https://github.com/hij1nx/EventEmitter2
   *
   * Copyright (c) 2013 hij1nx
   * Licensed under the MIT license.
   *)
*/
//# sourceMappingURL=react-quill.js.map
